<!-- STOP
  This file was generated by a rundoc script, do not modify it.

  Instead modify the rundoc script and re-run it.

  Command: /Users/rschneeman/.gem/ruby/3.4.2/bin/rundoc docs/RUNDOC.md
STOP -->
## Create the project

Create a top level workspace directory

```term
$ mkdir cache_diff
$ cd cache_diff
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Now initialize two projects:

```
$ cargo init cache_diff --lib
    Creating library package
note: see more `Cargo.toml` keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
$ cargo init cache_diff_derive --lib
    Creating library package
note: see more `Cargo.toml` keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Tell Rust that these two projects live under one unified workspace by creating a `Cargo.toml` in the root (one directory above the projects you just made):

```
[workspace]
members = [
    "cache_diff",
    "cache_diff_derive"
]
resolver = "2"
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

In file `.gitignore` write:

```
target/
.DS_Store
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->


The project now looks like this:

```
$ exa --tree --git-ignore .
.
├── cache_diff
│  ├── Cargo.toml
│  └── src
│     └── lib.rs
├── cache_diff_derive
│  ├── Cargo.toml
│  └── src
│     └── lib.rs
└── Cargo.toml
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

We need two crates because a procmacro must live in a stand alone crate. This allows Rust to compile and run that code before the rest of the code in a project is compiled. A limitation is that it can only export macros, so we need somewhere else for other public things (like traits) to live.

## Define the CacheDiff trait

Once the project is setup, we'll start off by defining a public trait:

```rust
// File: `cache_diff/src/lib.rs`

// Code
pub trait CacheDiff {
    fn diff(&self, old: &Self) -> Vec<String>;
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

>note
>This is how I recommend starting: define a manual workflow first and once you're happy with that, then move on to automation/metaprogramming via proc-macro.

This trait is short. It's designed to communicate that a struct is intended to be used as a cache key. When compared to an older version of the struct, it should return an empty `Vec` if there are no differences (and the cache should be preserved). When the cache should be cleared, the entries represent list of human readable reasons why the cache was cleared (what is different between the two structs). The primary use case is that "metadata" structs are serialized to TOML to know when we can invalidate a layer in a [Cloud Native Buildpack (CNB) written in Rust with the libcnb.rs](https://github.com/heroku/libcnb.rs).

## Manually implement the trait

Without a macro, a maintainer would need to manually implement the trait, here's a test demonstrating what that would look like.

First we will add a stringly typed `Metadata` struct and implement `CacheDiff` for this struct to simulate a world where we're storing a version of an architecture dependent binary that we're installing:

```rust
// File: `cache_diff/src/lib.rs`

// Code
// ...

#[cfg(test)]
mod tests {
    // Test use
    use super::*;
    // Test code
    struct Metadata {
        ruby_version: String,
        architecture: String,
    }

    impl CacheDiff for Metadata {
        fn diff(&self, old: &Self) -> Vec<String> {
            let mut diff = Vec::new();

            if self.ruby_version != old.ruby_version {
                diff.push(format!("ruby version ({} to {})",
                old.ruby_version,
                self.ruby_version))
            }
            if self.architecture != old.architecture {
                diff.push(
                    format!("architecture ({} to {})",
                    old.architecture,
                    self.architecture)
                )
            }
            diff
        }
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

> Skip the rest of this section if: You already understand how the trait interface could be used and could write your own tests for it.

Now, add a test for this behavior:

```rust
// File: `cache_diff/src/lib.rs`

// Code
// ...

#[cfg(test)]
mod tests {
    // Test use
    // ...

    // Test code
    // ...
    #[test]
    fn test_changed_metadata() {
        let old = Metadata {
            ruby_version: "3.3.1".to_string(),
            architecture: "amd64".to_string()
        };
        let new = Metadata {
            ruby_version: "3.4.2".to_string(),
            architecture: "arm64".to_string()
        };

        assert_eq!(
            vec![
                "ruby version (3.3.1 to 3.4.2)".to_string(),
                "architecture (amd64 to arm64)".to_string()
            ],
            new.diff(&old)
        );
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

It's usually a good idea to assert both positive an negative behavior:

```rust
// File: `cache_diff/src/lib.rs`

// Code
// ...

#[cfg(test)]
mod tests {
    // Test use
    // ...

    // Test code
    // ...
    #[test]
    fn test_unchanged_metadata() {
        let old = Metadata {
            ruby_version: "3.1.4".to_string(),
            architecture: "amd64".to_string()
        };

        let diff = old.diff(&old);
        assert!(
            diff.is_empty(),
            "Expected diff to be empty but is {:?}",
            diff
        );
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Your file should now look like this:

```rust
// File: `cache_diff/src/lib.rs`

// Code
pub trait CacheDiff {
    fn diff(&self, old: &Self) -> Vec<String>;
}

#[cfg(test)]
mod tests {
    // Test use
    use super::*;
    // Test code
    struct Metadata {
        ruby_version: String,
        architecture: String,
    }

    impl CacheDiff for Metadata {
        fn diff(&self, old: &Self) -> Vec<String> {
            let mut diff = Vec::new();

            if self.ruby_version != old.ruby_version {
                diff.push(format!("ruby version ({} to {})",
                old.ruby_version,
                self.ruby_version))
            }
            if self.architecture != old.architecture {
                diff.push(
                    format!("architecture ({} to {})",
                    old.architecture,
                    self.architecture)
                )
            }
            diff
        }
    }

    #[test]
    fn test_changed_metadata() {
        let old = Metadata {
            ruby_version: "3.3.1".to_string(),
            architecture: "amd64".to_string()
        };
        let new = Metadata {
            ruby_version: "3.4.2".to_string(),
            architecture: "arm64".to_string()
        };

        assert_eq!(
            vec![
                "ruby version (3.3.1 to 3.4.2)".to_string(),
                "architecture (amd64 to arm64)".to_string()
            ],
            new.diff(&old)
        );
    }

    #[test]
    fn test_unchanged_metadata() {
        let old = Metadata {
            ruby_version: "3.1.4".to_string(),
            architecture: "amd64".to_string()
        };

        let diff = old.diff(&old);
        assert!(
            diff.is_empty(),
            "Expected diff to be empty but is {:?}",
            diff
        );
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

And when you run tests, it should look a little like this:

```
$ cargo test
   Compiling cache_diff_derive v0.1.0 (/private/var/folders/yr/yytf3z3n3q336f1tj2b2j0gw0000gn/T/d20250304-34020-kjphav/cache_diff/cache_diff_derive)
   Compiling cache_diff v0.1.0 (/private/var/folders/yr/yytf3z3n3q336f1tj2b2j0gw0000gn/T/d20250304-34020-kjphav/cache_diff/cache_diff)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.17s
     Running unittests src/lib.rs (target/debug/deps/cache_diff-2716017b25caff21)

running 2 tests
test tests::test_unchanged_metadata ... ok
test tests::test_changed_metadata ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/lib.rs (target/debug/deps/cache_diff_derive-5abb2abc0d81814e)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests cache_diff

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests cache_diff_derive

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

The `CacheDiff` trait isn't too complicated, but there's a lot of repetition since the text of the output matches the field names (i.e. `metadata.version`), and there's room to mess up the output like inverting the version number position or comparing one field and displaying values for a different one.

If only there was a way to reduce repetition and eliminate silly logic errors. Some kind of code that could reflect on the struct we want to write and generate that output for us. Lucky for us, there is! That's what we'll work towards next.
## Understanding Derive macros and their configuration

> Skip this if: You are extremely familiar with derive macros and their associated terminology and interfaces.

A derive macro lets us implement traits on data structures with sensible defaults. A popular library that has a derive macro is [`serde`](https://serde.rs/) a (ser)ialiazation/(de)serialization library. Here's an example using [v1.0.218](https://docs.rs/serde/1.0.218/serde/index.html):

```rust
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
struct Metadata {
    version: String,
    architecture: String,
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

In addition to being able to define a top level trait that we want to derive, we can also configure it with other values called attributes. It's convention to name your attribute a lowercased name of your trait, so we will use the `#[cache_diff(...)]` attribute namespace.

Technically we could use any format or DSL inside of the parens, but it's usually a good idea to mimic existing interfaces that people are already comfortable with. Most attributes take `<key> = <value>` and `<stand-alone-key>` formats.  Here's an example of some attributes on serde:

```rust
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
struct Metadata {
    #[serde(rename = "ruby_version")]
    version: String,
    architecture: String,
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

There are two attributes here, the first one `#[serde(deny_unknown_fields)]` is a "container" attribute, because it affects the whole `struct Metadata` that it is above. It's called a "container attribute" because it operates on the thing containing the data (struct/enum/etc.). This attribute of serde [errors if you try to deserialize a field it's not expecting](https://serde.rs/container-attrs.html).

The second attribute is `#[serde(rename = "ruby_version")]`. This is a "field attribute" because it applies to the `version: String` field it is above. This [rename attribute](https://serde.rs/field-attrs.html) changes the name of the key used for serialization and deserialization so it will be `ruby_version` instead of `version`.

To recap:

- A container attribute operates on a data structure like `struct Metadata`.
- A field attribute operates on an individual field of that data structure like `version: String`.

There's another type of attribute called "variant attributes" which apply to enum variants, but we won't be using them in this tutorial.

### Explore the interface space by hand

We could jump write into writing a derive macro, but I want to spend a moment to consider how we want our final project to look like from our user's perspective. In the real world, I prototyped that trait, and implemented it manually for several layers to understand the problem space.

### Explore: Don't ignore the signs

One of my structs had some data that I wasn't using as a cache key for invalidation, it was recording the number of times the cache had been written to, when it changed I didn't want that to invalidate the cache. This informed me that I should have a way of skipping or ignoring fields that shouldn't be considered cache keys.

### Explore: Display play

Another struct had a different problem, it contained a [`std::path::PathBuf`](https://doc.rust-lang.org/std/path/struct.PathBuf.html) that should invalidate the cache when it changed. If you've worked with Rust for awhile you might guess the problem, if not I'll spoil the surprise: this type does not directly implement [std::fmt::Display](https://doc.rust-lang.org/std/fmt/trait.Display.html).

What that means is you cannot directly use it in a `format!()` or `println!()` macro or it will error.  If you try to run this code:

```rust
fn main() {
    println!(
    "Cannot display Path directly {}",
    std::path::PathBuf::from("src/lib.rs")
    );
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Then it will produce this error:

```
   Compiling lol v0.1.0 (/private/var/folders/yr/yytf3z3n3q336f1tj2b2j0gw0000gn/T/d20250304-34020-kjphav/lol)
error[E0277]: `PathBuf` doesn't implement `std::fmt::Display`
 --> src/main.rs:4:5
  |
4 |     std::path::PathBuf::from("src/lib.rs")
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `PathBuf` cannot be formatted with the default formatter; call `.display()` on it
  |
  = help: the trait `std::fmt::Display` is not implemented for `PathBuf`
  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
  = note: call `.display()` or `.to_string_lossy()` to safely print paths, as they may contain non-Unicode data
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0277`.
error: could not compile `lol` (bin "lol" test) due to 1 previous error
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

The [std::path::PathBuf::display() function docs](https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.display) show how you can call `display()` on it to print or format the value.

What this use case tells me is that I need to provide a way for developers to specify how to `Display` a value even if the type they're using as a cache key doesn't implement it directly.

### Explore: Doc driven design

With those two use cases in mind, we can explore what the interface could look like. We'll use the `Metadata` struct from earlier. We don't have any proc macro code, but we're going to write some pseduo code of what the interface could look like. This is sometimes called README driven design or Documentation driven design.

The simplest case could look like this:

```rust
use cache_diff::CacheDiff;

#[derive(CacheDiff)]
struct Metadata {
    ruby_version: String,
    architecture: String,
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

In this scenario we would create a derive proc macro that mirrors our trait name. The inputs to a derive proc macro is the AST of the Rust code, from this we have access to fields like `version:` and their types like `String`. This example is enough implement the hand-rolled trait trait that we used in our test, but what about our edge cases:

- Ignore a field that shouldn't invalidate the cache
- Display types that don't implement `Display`

Before we saw that an attribute can be a single key like `#[serde(deny_unknown_fields)]`. Since our project is named `CacheDiff` we could implement an `ignore` key like:

```rust
use cache_diff::CacheDiff;

#[derive(CacheDiff)]
struct Metadata {
    ruby_version: String,
    architecture: String,

    #[cache_diff(ignore)]
    cache_count: usize
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

What about configuring a custom display function? For that we'll need to use a key and value like we saw with `#[serde(rename = "ruby_version")]` but unlike that interface we don't want to configure a static string, we want to give it a path to a dynamic function, thankfully that's possible. We could have the API for that interface look somewhat like this:

```rust
use cache_diff::CacheDiff;

#[derive(CacheDiff)]
struct Metadata {
    ruby_version: String,
    architecture: String,

    #[cache_diff(display = std::path::PathBuf::display)]
    binary_location: std::path::PathBuf
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

In this code:

```
#[cache_diff(display = std::path::PathBuf::display)]
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

The attribute key will be `display` and the path to the function we want to use will be `std::path::PathBuf::display` which is a [function](https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.display).

These are sketches of what the code could look like. Here's the IRL README docs that I wrote for these two attributes:

- [Field attribute: `cache_diff(ignore)`](https://github.com/heroku-buildpacks/cache_diff/blob/fc854c0a1f0e89868bf3d822611dd21229af46f3/cache_diff/README.md#ignore-attributes)
- [Field attribute: `cache_diff(display = <code path>)`](https://github.com/heroku-buildpacks/cache_diff/blob/fc854c0a1f0e89868bf3d822611dd21229af46f3/cache_diff/README.md#handle-structs-missing-display)


In addition to these cutomizations, users also want:

- [The ability to rename  fields. Field attribute: `cache_diff(rename = "<new name>")`](https://github.com/heroku-buildpacks/cache_diff/blob/fc854c0a1f0e89868bf3d822611dd21229af46f3/cache_diff/README.md#rename-attributes)
- [Customize cache behavior for some fields without having to manually implement the trait for the rest. Container attribute: `cache_diff(custom = <code path>)`](hhttps://github.com/heroku-buildpacks/cache_diff/blob/fc854c0a1f0e89868bf3d822611dd21229af46f3/cache_diff/README.md#custom-logic-for-one-field-example)

Now that we know what we want the destination to look like, we're ready to start writing our proc macro!
## Proc, meet macro

> Skip this section if: You know how to start a proc macro project and are somehow not aware that you're reading a proc macro tutorial.

To write a proc macro we will need some crates. It's easier to see what they do as we use them.

At the end of `cache_diff_derive/Cargo.toml` add:

```toml
# Turn Rust code into Tokens
quote = "1.0.37"
# Parse tokens into Rust code
syn = { version = "2.0.83", features = ["extra-traits"] }
proc-macro2 = "1.0.89"
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

We also need to tell rust that this library is a proc macro.

At the end of `cache_diff_derive/Cargo.toml` add:

```toml
[lib]
proc-macro = true
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Now we need to add an entrypoint:

```rust




// File: `cache_diff_derive/src/lib.rs`
use proc_macro::TokenStream;

// Code
pub(crate) const NAMESPACE: &str = "cache_diff";
pub(crate) const MACRO_NAME: &str = "CacheDiff";

#[proc_macro_derive(CacheDiff, attributes(cache_diff))]
pub fn cache_diff(item: TokenStream)
    -> TokenStream {
    create_cache_diff(item.into())
        .unwrap_or_else(syn::Error::into_compile_error)
        .into()
}

fn create_cache_diff(item: proc_macro2::TokenStream)
    -> syn::Result<proc_macro2::TokenStream> {
    Ok(quote::quote! { })
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

This creates a function `cache_diff` that is annotated with a proc macro (how meta):

```rust
#[proc_macro_derive(CacheDiff, attributes(cache_diff))]
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

This line says that we provide a derive macro named `CacheDiff` and that it should accept some attributes that start with `#[cache_diff()]`. Originally I thought that meant it would only show me the attributes I was interested in, but it doesn't. If the struct has different attributes from different crates (remember `serde`?) then we can see them, we need to manually filter attributes so we only see the ones we care about.

The next bit defines a function `cache_diff` that will receive a `proc_macro::TokenStream` containing information about the code we're annotating:

```rust
pub fn cache_diff(item: TokenStream)
    -> TokenStream {
    create_cache_diff(item.into())
        .unwrap_or_else(syn::Error::into_compile_error)
        .into()
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

It calls a function `create_cache_diff` which returns a `syn::Result<proc_macro2::TokenStream>>`. That's effectively either a parse error or a stream of tokens. In the event of an error we want to map it into a pretty compile error with source code highlighting where the problem happend that Rust users know and love. Inside of the `create_cache_diff` function I added a call to the `quote::quote!` macro:

```rust
fn create_cache_diff(item: proc_macro2::TokenStream)
    -> syn::Result<proc_macro2::TokenStream> {
    Ok(quote::quote! { })
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

This macro takes converts text into rust code, we can also pass in variables, but for now we just want the code to compile:

```term
$ cargo build
    Updating crates.io index
     Locking 4 packages to latest compatible versions
      Adding proc-macro2 v1.0.94
      Adding quote v1.0.39
      Adding syn v2.0.99
      Adding unicode-ident v1.0.18
   Compiling proc-macro2 v1.0.94
   Compiling unicode-ident v1.0.18
   Compiling quote v1.0.39
   Compiling syn v2.0.99
   Compiling cache_diff_derive v0.1.0 (/private/var/folders/yr/yytf3z3n3q336f1tj2b2j0gw0000gn/T/d20250304-34020-kjphav/cache_diff/cache_diff_derive)
warning: unused variable: `item`
  --> cache_diff_derive/src/lib.rs:16:22
   |
16 | fn create_cache_diff(item: proc_macro2::TokenStream)
   |                      ^^^^ help: if this is intentional, prefix it with an underscore: `_item`
   |
   = note: `#[warn(unused_variables)]` on by default

warning: constant `NAMESPACE` is never used
 --> cache_diff_derive/src/lib.rs:5:18
  |
5 | pub(crate) const NAMESPACE: &str = "cache_diff";
  |                  ^^^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: constant `MACRO_NAME` is never used
 --> cache_diff_derive/src/lib.rs:6:18
  |
6 | pub(crate) const MACRO_NAME: &str = "CacheDiff";
  |                  ^^^^^^^^^^

warning: `cache_diff_derive` (lib) generated 3 warnings
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.96s
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Congrats! You just wrote your first proc macro! To use it we'll need to expose it through our non-derive crate that also carries the trait definition. First declare a dependency on our derive crate:

At the end of `cache_diff/Cargo.toml` add:

```toml
cache_diff_derive = { version = "0.1.0" , optional = true, path = "../cache_diff_derive" }

[features]
derive = ["dep:cache_diff_derive"]
default = ["derive"]
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

This declares a dependency on our derive macro, it's optional because...why not. Some people might want to rely on the trait and manually implement it without the overhead of pulling in the derive macro. But I'm making the assumption that people want to use it by default.

Now we re-export that macro right next to our trait:

```rust
// File: `cache_diff/src/lib.rs`
pub use cache_diff_derive::CacheDiff;

// Code
// ...
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

The file should look like this:

```rust
// File: `cache_diff/src/lib.rs`
pub use cache_diff_derive::CacheDiff;

// Code
pub trait CacheDiff {
    fn diff(&self, old: &Self) -> Vec<String>;
}

#[cfg(test)]
mod tests {
    // Test use
    use super::*;
    // Test code
    struct Metadata {
        ruby_version: String,
        architecture: String,
    }

    impl CacheDiff for Metadata {
        fn diff(&self, old: &Self) -> Vec<String> {
            let mut diff = Vec::new();

            if self.ruby_version != old.ruby_version {
                diff.push(format!("ruby version ({} to {})",
                old.ruby_version,
                self.ruby_version))
            }
            if self.architecture != old.architecture {
                diff.push(
                    format!("architecture ({} to {})",
                    old.architecture,
                    self.architecture)
                )
            }
            diff
        }
    }

    #[test]
    fn test_changed_metadata() {
        let old = Metadata {
            ruby_version: "3.3.1".to_string(),
            architecture: "amd64".to_string()
        };
        let new = Metadata {
            ruby_version: "3.4.2".to_string(),
            architecture: "arm64".to_string()
        };

        assert_eq!(
            vec![
                "ruby version (3.3.1 to 3.4.2)".to_string(),
                "architecture (amd64 to arm64)".to_string()
            ],
            new.diff(&old)
        );
    }

    #[test]
    fn test_unchanged_metadata() {
        let old = Metadata {
            ruby_version: "3.1.4".to_string(),
            architecture: "amd64".to_string()
        };

        let diff = old.diff(&old);
        assert!(
            diff.is_empty(),
            "Expected diff to be empty but is {:?}",
            diff
        );
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

With this skeleton in place, we will define structs to hold data, this will allow us to implement the base behavior and gradually add on custom attributes.
## Define a Field

> Skip this if you don't want your code to compile

You may recall that a field in our context refers to a name and type within a struct. We need a way to model this in our code so we can add onto it later:

```rust
// File: `cache_diff_derive/src/parse_field.rs`

// Code
/// Field (i.e. `name: String`) of a container (struct) and its parsed attributes
/// i.e. `#[cache_diff(rename = "Ruby version")]`
#[derive(Debug)]
pub(crate) struct ParseField {
    /// The proc-macro identifier for a field i.e. `name: String` would be a programatic
    /// reference to `name` that can be used along with `quote!` to produce code.
    pub(crate) ident: syn::Ident,
    /// What the user will see when this field differs and invalidates the cache
    /// i.e. `age: usize` will be `"age"`.
    pub(crate) name: String,
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

The interesting bits here is that the `ident` field holds a `syn::Ident` which is shorthand for an "identifier" of Rust code, we'll use this when we want to compare one field value to another so `old.version != new.version` would become `old.#ident != new.#ident`. Then we store the name of the field we want to show when a difference is detected. We want it to look nice, so instead of showing a string like `"ruby_version"` we'll convert it to `"ruby version"` (with a space instead of an underscore). This isn't strictly required at this point, but we're laying a foundation to build on.

To use this code we've got to `mod` it from the `lib.rs`

```rust
// File: `cache_diff_derive/src/lib.rs`
mod parse_field;
// Use ...


// Code
// ...
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Now that we've got somewhere to put data, we need some logic:

```rust



// File: `cache_diff_derive/src/parse_field.rs`
use crate::MACRO_NAME;
use syn::spanned::Spanned;

// Code
// ...
impl ParseField {
    pub(crate) fn from_field(field: &syn::Field) -> Result<Self, syn::Error> {
        let ident = field.ident.clone().ok_or_else(|| {
            syn::Error::new(
                field.span(),
                format!("{MACRO_NAME} can only be used on structs with named fields"),
            )
        })?;

        let name = ident.to_string().replace("_", " ");

        Ok(ParseField {
            ident,
            name,
        })
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

The function we added takes in a `syn::Field`, a parsing abstraction over a struct's fields and returns itself of a `syn::Error`:

```rust
    pub(crate) fn from_field(field: &syn::Field) -> Result<Self, syn::Error> {
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Syn provides a number of these abstractions out of the box, you can find a list at TODO.

This next bit of code pulls out the identity of the field if there is one, or returns `syn::Error` one isn't provided:

```rust
        let ident = field.ident.clone().ok_or_else(|| {
            syn::Error::new(
                field.span(),
                format!("{MACRO_NAME} can only be used on structs with named fields"),
            )
        })?;
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

As the error message suggests, this might be `None` if someone tried to use our derive macro on something that has a field without an ident like a tuple struct (i.e. `struct Metadata(String)`). The first argument of the error takes in a `Span`. This is a common parsing abstraction, it represents a sequence of characters in our input. The `syn` crate uses this information to make nice error messages with references to our code that Rust developers have come to expect. To get the span from the field input we have to import the `Spanned` trait.

From there we gather the string representation of our identity, and replace underscores with spaces:

```rust
        let name = ident.to_string().replace("_", " ");
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

But don't take my word for it, let's see the code in action:



This code uses `syn::parse_quote!` macro to generate a `syn::Field` that we can use to pass to the associated function we just defined. We have to annotate the type in the test or syn won't know what data structure we're trying to represent in our code. From there it asserts our naming logic works as expected.

Happy paths are nice and all, but what about that error from earlier?



> Protip: To assert the full output, you could use the [trybuild crate]().

This is our code so far:

```rust
// File: `cache_diff_derive/src/parse_field.rs`
use crate::MACRO_NAME;
use syn::spanned::Spanned;

// Code
/// Field (i.e. `name: String`) of a container (struct) and its parsed attributes
/// i.e. `#[cache_diff(rename = "Ruby version")]`
#[derive(Debug)]
pub(crate) struct ParseField {
    /// The proc-macro identifier for a field i.e. `name: String` would be a programatic
    /// reference to `name` that can be used along with `quote!` to produce code.
    pub(crate) ident: syn::Ident,
    /// What the user will see when this field differs and invalidates the cache
    /// i.e. `age: usize` will be `"age"`.
    pub(crate) name: String,
}

impl ParseField {
    pub(crate) fn from_field(field: &syn::Field) -> Result<Self, syn::Error> {
        let ident = field.ident.clone().ok_or_else(|| {
            syn::Error::new(
                field.span(),
                format!("{MACRO_NAME} can only be used on structs with named fields"),
            )
        })?;

        let name = ident.to_string().replace("_", " ");

        Ok(ParseField {
            ident,
            name,
        })
    }
}

#[cfg(test)]
mod tests {
    // Test use
    use super::*;
    // Test code
    #[test]
    fn test_parse_field_plain() {
        let field: syn::Field = syn::parse_quote! {
            ruby_version: String
        };

        let parsed = ParseField::from_field(&field).unwrap();
        assert_eq!("ruby version".to_string(), parsed.name);
    }

    #[test]
    fn test_requires_named_struct() {
        let field: syn::Field = syn::parse_quote! {()};

        let result = ParseField::from_field(&field);
        assert!(result.is_err(), "Expected an error, got {:?}", result);
        assert_eq!(
            format!("{}", result.err().unwrap()),
            r#"CacheDiff can only be used on structs with named fields"#
        );
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Run tests to make sure everything works as expected:

```
$ cargo test
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Now that we have a representation for a field, let's model our container.
## Define the Container

> Skip this if you don't want your code to compile

If you didn't skip over it, you may remember that a container in proc-macro land refers to a struct or enum. We want a way to model a container that holds zero or more named fields:

```rust


// File: `cache_diff_derive/src/parse_container.rs`
use crate::parse_field::ParseField;

// Code
/// Container (i.e. struct Metadata { ... }) and its parsed attributes
/// i.e. `#[cache_diff( ... )]`
#[derive(Debug)]
pub(crate) struct ParseContainer {
    /// The proc-macro identifier for a container i.e. `struct Metadata { }` would be a programatic
    /// reference to `Metadata` that can be used along with `quote!` to produce code.
    pub(crate) ident: syn::Ident,
    /// Fields (i.e. `name: String`) and their associated attributes i.e. `#[cache_diff(...)]`
    pub(crate) fields: Vec<ParseField>,
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Like before, we're holding a reference to `syn::Ident` which holds the identity of the struct. Then, instead of holding a `syn` data type for fields, we're holding a `Vec` of our the `ParseField` struct we defined previously.

Don't forget to let our project know about the new file by adding a `mod` declaration:

```rust
// File: `cache_diff_derive/src/lib.rs`
// Mod ...
mod parse_container;
// Use ...


// Code
// ...
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Now that we've got a place to hold the data, let's build it from the input AST:

```rust
// File: `cache_diff_derive/src/parse_container.rs`
// Use ...
use crate::MACRO_NAME;

// Code
// ...
impl ParseContainer {
    pub(crate) fn from_derive_input(input: &syn::DeriveInput) -> Result<Self, syn::Error> {
        let ident = input.ident.clone();
        let fields = match input.data {
            syn::Data::Struct(syn::DataStruct {
                fields: syn::Fields::Named(syn::FieldsNamed { ref named, .. }),
                ..
            }) => named,
            _ => {
                return Err(syn::Error::new(
                    ident.span(),
                    format!("{MACRO_NAME} can only be used on named structs"),
                ))
            }
        }
        .into_iter()
        .map(ParseField::from_field)
        .collect::<Result<Vec<ParseField>, syn::Error>>()?;

        Ok(ParseContainer { ident, fields })
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

The function takes in a `syn::DeriveInput` and returns itself or a `syn::Error` (just like `ParseField` did!):

```rust
    pub(crate) fn from_derive_input(input: &syn::DeriveInput) -> Result<Self, syn::Error> {
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

While `ParseField` took in a `syn::Field`, there's no pre-defined "container" type from syn, instead `syn::DeriveInput` is anything that could be passed to a derive macro. And since derive macros can only be applied to containers you can mentally substitute "container" every time you see "Derive Input".

All containers must be named so we can pull an identity directly (without needint to raise an error like we did with fields):

```rust
        let ident = input.ident.clone();
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

This next bit is tricky:

```rust
        let fields = match input.data {
            syn::Data::Struct(syn::DataStruct {
                fields: syn::Fields::Named(syn::FieldsNamed { ref named, .. }),
                ..
            }) => named,
            _ => {
                return Err(syn::Error::new(
                    ident.span(),
                    format!("{MACRO_NAME} can only be used on named structs"),
                ))
            }
        }
        .into_iter()
        .map(ParseField::from_field)
        .collect::<Result<Vec<ParseField>, syn::Error>>()?;
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Because derive input (a.k.a containers) can be different shapes (struct, enum, or union) we can use a match statement to pull out the information we need from named fields.

The return value from `syn::Data` here is a `&syn::Punctuated<syn::Field, syn::Token::Comma>` which is a fancy way of saying that it's a `syn::Field` that is separated by comma's. We can iterate over that type to yield `&syn::Field`, which is exactly what our `ParseField` function takes in:

```rust
        .into_iter()
        .map(ParseField::from_field)
        .collect::<Result<Vec<ParseField>, syn::Error>>()?;
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

If that parsing is successful then we've got our data! But not so fast cowpoke, we can't mosey on until we write some tests:

```rust

// File: `cache_diff_derive/src/parse_container.rs`
// Use ...


// Code
// ...

#[cfg(test)]
mod tests {
    // Test use
    use super::*;
    // Test code
    #[test]
    fn test_parses() {
        let container = ParseContainer::from_derive_input(&syn::parse_quote! {
            struct Metadata {
                version: String
            }
        })
        .unwrap();
        assert_eq!(1, container.fields.len());

        let container = ParseContainer::from_derive_input(&syn::parse_quote! {
            struct Metadata {
                version: String,
                checksum: String
            }
        })
        .unwrap();
        assert_eq!(2, container.fields.len());
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Verify it works:

```
$ cargo test
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

At this point, we've got a custom representation for our fields and for the container (that holds the fields). We'll use this to generate a simple version of our trait before extending our simple data structures to hold attribute information.
## Container + Fields == Happy Derive Macro


Import the structs we created:

```rust


// File: `cache_diff_derive/src/lib.rs`
// Mod ...

// Use ...
use parse_container::ParseContainer;
use parse_field::ParseField;

// Code
// ...
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Replace our prior cache logic:

```rust
// File: `cache_diff_derive/src/lib.rs`
// Mod ...

// Use ...


// Code
// ...
fn create_cache_diff(item: proc_macro2::TokenStream)
    -> syn::Result<proc_macro2::TokenStream> {
    Ok(quote::quote! { })
}


```

With with these new contents:


```rust
// File: `cache_diff_derive/src/lib.rs`
// Mod ...

// Use ...


// Code
// ...
fn create_cache_diff(item: proc_macro2::TokenStream)
    -> syn::Result<proc_macro2::TokenStream> {
    let derive_input: syn::DeriveInput = syn::parse2(item)?;
    let container = ParseContainer::from_derive_input(&derive_input)?;
    let struct_identifier = &container.ident;

    let mut comparisons = Vec::new();
    for field in container.fields.iter() {
        let ParseField {
            ident,
            name,
            ..
        } = field;

        comparisons.push(quote::quote! {
            if self.#ident != old.#ident {
                differences.push(
                    format!("{name} ({old} to {new})",
                        name = #name,
                        old = &old.#ident,
                        new = &self.#ident,
                    )
                );
            }
        });
    }

    Ok(quote::quote! {
        impl cache_diff::CacheDiff for #struct_identifier {
            fn diff(&self, old: &Self) -> ::std::vec::Vec<String> {
                let mut differences = ::std::vec::Vec::new();
                #(#comparisons)*
                differences
            }
        }
    })
}


```

That's a lot of code, let's break it down. The first thing we do is generate a `syn::DeriveInput` from the token stream:

```rust
    let derive_input: syn::DeriveInput = syn::parse2(item)?;
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

The function `syn::parse2` is especially designed to turn a `proc_macro2::TokenStream` into a syn struct such as `syn::DeriveInput`. Next we build our container structure from this parsed input:

```rust
    let container = ParseContainer::from_derive_input(&derive_input)?;
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

We will need the identity of the container (i.e. `Metadata`) for code generation later with the `quote::quote!` macro:

```rust
    let struct_identifier = &container.ident;
    // ...
    Ok(quote::quote! {
        impl cache_diff::CacheDiff for #struct_identifier {
            fn diff(&self, old: &Self) -> ::std::vec::Vec<String> {
                let mut differences = ::std::vec::Vec::new();
                #(#comparisons)*
                differences
            }
        }
    })
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

In the above code, variables can be substituted inorder to generate code by leading them with a pound. For example, `#struct_identifier` will be replaced with ident from the `let struct_identifier` variable. The `#(#comparisons)*` code expands the `let comparisons` variable which contains a `Vec<proc_macro2::TokenStream>` which is generated via the `quote::quote!` macro (which we'll look into in a minute). You can read more about [this syntax in the quote docs](https://docs.rs/quote/1.0.38/quote/macro.quote.html#interpolation). The `#()*` syntax handles repetition since the variable is a Vec. From the quote docs:

> Repetition is done using #(...)* or #(...),* again similar to macro_rules!. This iterates through the elements of any variable interpolated within the repetition and inserts a copy of the repetition body for each one. The variables in an interpolation may be a Vec, slice, BTreeSet, or any Iterator.

We skipped ahead of how we generated those comparisons. Let's go back and look at it now:

```rust
    let mut comparisons = Vec::new();
    for field in container.fields.iter() {
        let ParseField {
            ident,
            name,
            ..
        } = field;

        comparisons.push(quote::quote! {
            if self.#ident != old.#ident {
                differences.push(
                    format!("{name} ({old} to {new})",
                        name = #name,
                        old = &old.#ident,
                        new = &self.#ident,
                    )
                );
            }
        });
    }

    Ok(quote::quote! {
        impl cache_diff::CacheDiff for #struct_identifier {
            fn diff(&self, old: &Self) -> ::std::vec::Vec<String> {
                let mut differences = ::std::vec::Vec::new();
                #(#comparisons)*
                differences
            }
        }
    })
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

In this code we're looping through all of the fields and pulling out the identifier (i.e. `version` for `version: String`), as well as the un-underscored name. Like we saw with the struct identifier, we will use the `quote::quote!` macro and the inner variables `ident` and `name` to check if the current value does not equal the old value, and if that happens then format that information and add it to the vec.

Unfortunately we cannot test the derive macro invocation in the same crate, because the macro must be compiled first. However, we can test it in our original crate. Let's add a test to verify it works. We can use Rust's doctests to validate the happy path. At the top of `cache_diff/src/lib.rs` add module docs with a doctest that uses our derive macro:

```rust

// File: `cache_diff/src/lib.rs`
//! Cache Diff (derive)
//!
//! Generate the difference between two structs for the purposes of cache invalidation.
//!
//! Example:
//!
//! ```
//! use cache_diff::CacheDiff;
//!
//! #[derive(CacheDiff, Debug)]
//! struct Metadata {
//!     ruby_version: String,
//!     architecture: String,
//! }
//!
//! let diff = Metadata {ruby_version: "3.4.2".to_string(), architecture: "arm64".to_string()}
//!     .diff(&Metadata {ruby_version: "3.3.1".to_string(), architecture: "amd64".to_string()});
//!
//! assert_eq!(
//!     vec!["ruby version (3.3.1 to 3.4.2)".to_string(), "architecture (amd64 to arm64)".to_string()],
//!     diff
//! );
//! ```
// Use ...


// Code
// ...
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

This derive macro test is asserting the same behavior we implmemented manually before:

```rust
    impl CacheDiff for Metadata {
        fn diff(&self, old: &Self) -> Vec<String> {
            let mut diff = Vec::new();

            if self.ruby_version != old.ruby_version {
                diff.push(format!("ruby version ({} to {})",
                old.ruby_version,
                self.ruby_version))
            }
            if self.architecture != old.architecture {
                diff.push(
                    format!("architecture ({} to {})",
                    old.architecture,
                    self.architecture)
                )
            }
            diff
        }
    }

    #[test]
    fn test_changed_metadata() {
        let old = Metadata {
            ruby_version: "3.3.1".to_string(),
            architecture: "amd64".to_string()
        };
        let new = Metadata {
            ruby_version: "3.4.2".to_string(),
            architecture: "arm64".to_string()
        };

        assert_eq!(
            vec![
                "ruby version (3.3.1 to 3.4.2)".to_string(),
                "architecture (amd64 to arm64)".to_string()
            ],
            new.diff(&old)
        );
    }

    #[test]
    fn test_unchanged_metadata() {
        let old = Metadata {
            ruby_version: "3.1.4".to_string(),
            architecture: "amd64".to_string()
        };

        let diff = old.diff(&old);
        assert!(
            diff.is_empty(),
            "Expected diff to be empty but is {:?}",
            diff
        );
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Now verify it all works:

```
$ cargo test
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

If your project is failing or if the tests you added didn't run, here's the full project for reference:

<details>
  <summary>Full project</summary>

```
$ exa --tree --git-ignore .
.
├── cache_diff
│  ├── Cargo.toml
│  └── src
│     └── lib.rs
├── cache_diff_derive
│  ├── Cargo.toml
│  └── src
│     ├── lib.rs
│     ├── parse_container.rs
│     └── parse_field.rs
├── Cargo.lock
└── Cargo.toml
$ cat Cargo.toml
[workspace]
members = [
    "cache_diff",
    "cache_diff_derive"
]
resolver = "2"
$ cat cache_diff/Cargo.toml
[package]
name = "cache_diff"
version = "0.1.0"
edition = "2024"

[dependencies]
cache_diff_derive = { version = "0.1.0" , optional = true, path = "../cache_diff_derive" }

[features]
derive = ["dep:cache_diff_derive"]
default = ["derive"]
$ cat cache_diff_derive/Cargo.toml
[package]
name = "cache_diff_derive"
version = "0.1.0"
edition = "2024"

[dependencies]
# Turn Rust code into Tokens
quote = "1.0.37"
# Parse tokens into Rust code
syn = { version = "2.0.83", features = ["extra-traits"] }
proc-macro2 = "1.0.89"
[lib]
proc-macro = true
$ cat cache_diff/src/lib.rs
// File: `cache_diff/src/lib.rs`
//! Cache Diff (derive)
//!
//! Generate the difference between two structs for the purposes of cache invalidation.
//!
//! Example:
//!
//! ```
//! use cache_diff::CacheDiff;
//!
//! #[derive(CacheDiff, Debug)]
//! struct Metadata {
//!     ruby_version: String,
//!     architecture: String,
//! }
//!
//! let diff = Metadata {ruby_version: "3.4.2".to_string(), architecture: "arm64".to_string()}
//!     .diff(&Metadata {ruby_version: "3.3.1".to_string(), architecture: "amd64".to_string()});
//!
//! assert_eq!(
//!     vec!["ruby version (3.3.1 to 3.4.2)".to_string(), "architecture (amd64 to arm64)".to_string()],
//!     diff
//! );
//! ```
pub use cache_diff_derive::CacheDiff;

// Code
pub trait CacheDiff {
    fn diff(&self, old: &Self) -> Vec<String>;
}

#[cfg(test)]
mod tests {
    // Test use
    use super::*;
    // Test code
    struct Metadata {
        ruby_version: String,
        architecture: String,
    }

    impl CacheDiff for Metadata {
        fn diff(&self, old: &Self) -> Vec<String> {
            let mut diff = Vec::new();

            if self.ruby_version != old.ruby_version {
                diff.push(format!("ruby version ({} to {})",
                old.ruby_version,
                self.ruby_version))
            }
            if self.architecture != old.architecture {
                diff.push(
                    format!("architecture ({} to {})",
                    old.architecture,
                    self.architecture)
                )
            }
            diff
        }
    }

    #[test]
    fn test_changed_metadata() {
        let old = Metadata {
            ruby_version: "3.3.1".to_string(),
            architecture: "amd64".to_string()
        };
        let new = Metadata {
            ruby_version: "3.4.2".to_string(),
            architecture: "arm64".to_string()
        };

        assert_eq!(
            vec![
                "ruby version (3.3.1 to 3.4.2)".to_string(),
                "architecture (amd64 to arm64)".to_string()
            ],
            new.diff(&old)
        );
    }

    #[test]
    fn test_unchanged_metadata() {
        let old = Metadata {
            ruby_version: "3.1.4".to_string(),
            architecture: "amd64".to_string()
        };

        let diff = old.diff(&old);
        assert!(
            diff.is_empty(),
            "Expected diff to be empty but is {:?}",
            diff
        );
    }
}
$ cat cache_diff_derive/src/lib.rs
// File: `cache_diff_derive/src/lib.rs`
mod parse_field;
mod parse_container;
use proc_macro::TokenStream;
use parse_container::ParseContainer;
use parse_field::ParseField;

// Code
pub(crate) const NAMESPACE: &str = "cache_diff";
pub(crate) const MACRO_NAME: &str = "CacheDiff";

#[proc_macro_derive(CacheDiff, attributes(cache_diff))]
pub fn cache_diff(item: TokenStream)
    -> TokenStream {
    create_cache_diff(item.into())
        .unwrap_or_else(syn::Error::into_compile_error)
        .into()
}

fn create_cache_diff(item: proc_macro2::TokenStream)
    -> syn::Result<proc_macro2::TokenStream> {
    let derive_input: syn::DeriveInput = syn::parse2(item)?;
    let container = ParseContainer::from_derive_input(&derive_input)?;
    let struct_identifier = &container.ident;

    let mut comparisons = Vec::new();
    for field in container.fields.iter() {
        let ParseField {
            ident,
            name,
            ..
        } = field;

        comparisons.push(quote::quote! {
            if self.#ident != old.#ident {
                differences.push(
                    format!("{name} ({old} to {new})",
                        name = #name,
                        old = &old.#ident,
                        new = &self.#ident,
                    )
                );
            }
        });
    }

    Ok(quote::quote! {
        impl cache_diff::CacheDiff for #struct_identifier {
            fn diff(&self, old: &Self) -> ::std::vec::Vec<String> {
                let mut differences = ::std::vec::Vec::new();
                #(#comparisons)*
                differences
            }
        }
    })
}
$ cat cache_diff_derive/src/parse_field.rs
// File: `cache_diff_derive/src/parse_field.rs`
use crate::MACRO_NAME;
use syn::spanned::Spanned;

// Code
/// Field (i.e. `name: String`) of a container (struct) and its parsed attributes
/// i.e. `#[cache_diff(rename = "Ruby version")]`
#[derive(Debug)]
pub(crate) struct ParseField {
    /// The proc-macro identifier for a field i.e. `name: String` would be a programatic
    /// reference to `name` that can be used along with `quote!` to produce code.
    pub(crate) ident: syn::Ident,
    /// What the user will see when this field differs and invalidates the cache
    /// i.e. `age: usize` will be `"age"`.
    pub(crate) name: String,
}

impl ParseField {
    pub(crate) fn from_field(field: &syn::Field) -> Result<Self, syn::Error> {
        let ident = field.ident.clone().ok_or_else(|| {
            syn::Error::new(
                field.span(),
                format!("{MACRO_NAME} can only be used on structs with named fields"),
            )
        })?;

        let name = ident.to_string().replace("_", " ");

        Ok(ParseField {
            ident,
            name,
        })
    }
}

#[cfg(test)]
mod tests {
    // Test use
    use super::*;
    // Test code
    #[test]
    fn test_parse_field_plain() {
        let field: syn::Field = syn::parse_quote! {
            ruby_version: String
        };

        let parsed = ParseField::from_field(&field).unwrap();
        assert_eq!("ruby version".to_string(), parsed.name);
    }

    #[test]
    fn test_requires_named_struct() {
        let field: syn::Field = syn::parse_quote! {()};

        let result = ParseField::from_field(&field);
        assert!(result.is_err(), "Expected an error, got {:?}", result);
        assert_eq!(
            format!("{}", result.err().unwrap()),
            r#"CacheDiff can only be used on structs with named fields"#
        );
    }
}
$ cat cache_diff_derive/src/parse_container.rs
// File: `cache_diff_derive/src/parse_container.rs`
use crate::parse_field::ParseField;
use crate::MACRO_NAME;

// Code
/// Container (i.e. struct Metadata { ... }) and its parsed attributes
/// i.e. `#[cache_diff( ... )]`
#[derive(Debug)]
pub(crate) struct ParseContainer {
    /// The proc-macro identifier for a container i.e. `struct Metadata { }` would be a programatic
    /// reference to `Metadata` that can be used along with `quote!` to produce code.
    pub(crate) ident: syn::Ident,
    /// Fields (i.e. `name: String`) and their associated attributes i.e. `#[cache_diff(...)]`
    pub(crate) fields: Vec<ParseField>,
}

impl ParseContainer {
    pub(crate) fn from_derive_input(input: &syn::DeriveInput) -> Result<Self, syn::Error> {
        let ident = input.ident.clone();
        let fields = match input.data {
            syn::Data::Struct(syn::DataStruct {
                fields: syn::Fields::Named(syn::FieldsNamed { ref named, .. }),
                ..
            }) => named,
            _ => {
                return Err(syn::Error::new(
                    ident.span(),
                    format!("{MACRO_NAME} can only be used on named structs"),
                ))
            }
        }
        .into_iter()
        .map(ParseField::from_field)
        .collect::<Result<Vec<ParseField>, syn::Error>>()?;

        Ok(ParseContainer { ident, fields })
    }
}

#[cfg(test)]
mod tests {
    // Test use
    use super::*;
    // Test code
    #[test]
    fn test_parses() {
        let container = ParseContainer::from_derive_input(&syn::parse_quote! {
            struct Metadata {
                version: String
            }
        })
        .unwrap();
        assert_eq!(1, container.fields.len());

        let container = ParseContainer::from_derive_input(&syn::parse_quote! {
            struct Metadata {
                version: String,
                checksum: String
            }
        })
        .unwrap();
        assert_eq!(2, container.fields.len());
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->
</details>

Congrats! You just wrote a derive macro! But we're not done yet. Let's add some logic for parsing attributes to let users configure behavior without needing to manually implement the trait.
## Add field attributes

Our macro will need both field and container attributes. You may recall, that our readme driven development left us with three things to customize on the field:

- [cache_diff(ignore)](https://github.com/heroku-buildpacks/cache_diff/blob/fc854c0a1f0e89868bf3d822611dd21229af46f3/cache_diff/README.md#ignore-attributes)
- [cache_diff(display = <code path>)](https://github.com/heroku-buildpacks/cache_diff/blob/fc854c0a1f0e89868bf3d822611dd21229af46f3/cache_diff/README.md#handle-structs-missing-display)
- [cache_diff(rename = "<new name>")](https://github.com/heroku-buildpacks/cache_diff/blob/fc854c0a1f0e89868bf3d822611dd21229af46f3/cache_diff/README.md#rename-attributes)

And one thing to customize on the container:

- [Customize cache behavior for some fields without having to manually implement the trait for the rest. Container attribute: `cache_diff(custom = <code path>)`](hhttps://github.com/heroku-buildpacks/cache_diff/blob/fc854c0a1f0e89868bf3d822611dd21229af46f3/cache_diff/README.md#custom-logic-for-one-field-example)

Initial prototyping suggested that it was useful for developers to list why a certain field was ignored, so beyond a simple boolean flag for ignore, I decided that `cache_diff(ignore = "Reason why field is ignored")` should also be valid. In the real code I'm special casing `ignore = "custom"` to trigger an additional check.

Like before, we'll represent this state in code and fill out the rest of our program to be capable of generating that code. We will represent individual attributes as an enum, and use the [strum](https://crates.io/crates/strum) crate to make parsing and error generation easier:

```
$ cargo add strum@0.26 --package cache_diff_derive --features derive
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Now define the enum:

```rust

// File: `cache_diff_derive/src/parse_field.rs`
// Use ...
use std::str::FromStr;
use strum::IntoEnumIterator;

// Code
// ...
/// A single attribute
#[derive(strum::EnumDiscriminants, Debug, PartialEq)]
#[strum_discriminants(derive(strum::EnumIter, strum::Display, strum::EnumString))]
#[strum_discriminants(name(KnownAttribute))]
enum ParseAttribute {
    #[allow(non_camel_case_types)]
    rename(String), // #[cache_diff(rename="...")]
    #[allow(non_camel_case_types)]
    display(syn::Path), // #[cache_diff(display=<function>)]
    #[allow(non_camel_case_types)]
    ignore(String), // #[cache_diff(ignore)]
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

In addition to enum variants such as `ParseAttribute::rename(...)`, the strum crate is creating a "discriminant" enum that has the same named variants, but without any inputs. We're telling strum to name this enum `KnownAttribute` and give it the ability to iterate over all its variants (`strum::EnumIter`), print the name of each variant (`strum::Display`), and generate a variant from a string (`strum::EnumString`).

We will implement the `syn::parse::Parse` trait to allow syn to parse a stream of tokens into our data structures. We'll start off with our `KnownAttribute` enum:

```rust
// File: `cache_diff_derive/src/parse_field.rs`
// Use ...
use crate::NAMESPACE;

// Code
// ...
impl syn::parse::Parse for KnownAttribute {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let identity: syn::Ident = input.parse()?;
        KnownAttribute::from_str(&identity.to_string()).map_err(|_| {
            syn::Error::new(
                identity.span(),
                format!(
                    "Unknown {NAMESPACE} attribute: `{identity}`. Must be one of {valid_keys}",
                    valid_keys = KnownAttribute::iter()
                        .map(|key| format!("`{key}`"))
                        .collect::<Vec<String>>()
                        .join(", ")
                ),
            )
        })
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Here's how that translates to code:

```rust
// File: `cache_diff_derive/src/parse_field.rs`
// Use ...


// Code
// ...

#[cfg(test)]
mod tests {
    // Test use
    // ...

    // Test code
    // ...
    #[test]
    fn test_known_attributes() {
        let parsed: KnownAttribute = syn::parse_str("rename").unwrap();
        assert_eq!(KnownAttribute::rename, parsed);

        let parsed: KnownAttribute = syn::parse_str("ignore").unwrap();
        assert_eq!(KnownAttribute::ignore, parsed);

        let parsed: KnownAttribute = syn::parse_str("display").unwrap();
        assert_eq!(KnownAttribute::display, parsed);

        let result: Result<KnownAttribute, syn::Error> = syn::parse_str("unknown");
        assert!(result.is_err(), "Expected an error, got {:?}", result);
        assert_eq!(
            format!("{}", result.err().unwrap()),
            r#"Unknown cache_diff attribute: `unknown`. Must be one of `rename`, `display`, `ignore`"#
        );
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

We can now parse individual keywords such as `rename` into a `KnownAttribute` enum. We can use this to generate an implementation of `syn::parse::Parse` for our `ParseAttribute` which uses a `<key> = <value>` structure:

```rust
// File: `cache_diff_derive/src/parse_field.rs`
// Use ...


// Code
// ...
impl syn::parse::Parse for ParseAttribute {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let key: KnownAttribute = input.parse()?;

        match key {
            KnownAttribute::rename => {
                input.parse::<syn::Token![=]>()?;
                Ok(ParseAttribute::rename(
                    input.parse::<syn::LitStr>()?.value(),
                ))
            }
            KnownAttribute::display => {
                input.parse::<syn::Token![=]>()?;
                Ok(ParseAttribute::display(input.parse()?))
            }
            KnownAttribute::ignore => {
                if input.peek(syn::Token![=]) {
                    input.parse::<syn::Token![=]>()?;
                    Ok(ParseAttribute::ignore(
                        input.parse::<syn::LitStr>()?.value(),
                    ))
                } else {
                    Ok(ParseAttribute::ignore("default".to_string()))
                }
            }
        }
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Because we previously implemented `syn::parse::Parse` for `KnownAttribute`, we can parse the input and then match against the enum. When a `syn::parse::ParseStream` is parsed successfully, then that part of the stream is consumed. That means that in the case of `rename` and `display` we require that the user gives us an equal sign next. This can be parsed using `syn::Token![=]`:

```rust
input.parse::<syn::Token![=]>()?;
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

> Protip: If the whole `syn::parse::ParseStream` isn't consumed in the body of a parse implementation, then it will error. This would prevent `KnownAttribute` from accidentally parsing an input like `rename = "true"` as it would match the first ident `rename` but wouldn't consume the rest. The error from syn when this happend isn't very intuititve, so if you are puzzling why your parse invocation fails, make sure you've consumed everything. You can use `eprintln` to debug.

Once the equal sign is parsed, then we need to parse the value. A `syn::LitStr` will capture a string with quotes. So for an input of `rename = "Ruby VERSION"` the `syn::LitStr` will capture `"Ruby VERSION"`. We can extract a string from it by calling the `.value()` associated function:

```rust
Ok(ParseAttribute::rename(
    input.parse::<syn::LitStr>()?.value(),
))
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

The `display` attribute holds a `syn::Path` which is described as "A path at which a named item is exported." This allows us to accept a function like `my_display` or a fully qualified path to a function like: `std::path::PathBuf::display`. Because this is a syn type, we can parse directly into it without needing any type annotations:

```rust
Ok(ParseAttribute::display(input.parse()?))
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Finally, the `ignore` attribute can be used in one of two ways either `cache_diff(ignore)` or `cache_diff(ignore = "reason")`. To handle these two scenarios, we can inspect the `ParseStream` via `peek()` to see if it contains an equal or not. If it does, parse it and expect a literal string, if not, we'll default to some internal value. So far, the value is only used as a marker in the source to future developers for why it was ignored, so we could chose any default string, I picked "no reason given":


```rust
KnownAttribute::ignore => {
    if input.peek(syn::Token![=]) {
        input.parse::<syn::Token![=]>()?;
        Ok(ParseAttribute::ignore(
            input.parse::<syn::LitStr>()?.value(),
        ))
    } else {
        Ok(ParseAttribute::ignore("no reason given".to_string()))
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

With all that in place, you can add a test and validate that we can parse it into our data structure:

```rust
// File: `cache_diff_derive/src/parse_field.rs`
// Use ...


// Code
// ...

#[cfg(test)]
mod tests {
    // Test use
    // ...

    // Test code
    // ...
    #[test]
    fn test_parse_attributes() {
        let parsed: ParseAttribute = syn::parse_str(r#"rename = "Ruby version""#).unwrap();
        assert_eq!(ParseAttribute::rename("Ruby version".to_string()), parsed);

        let parsed: ParseAttribute = syn::parse_str(r#"display= my_function"#).unwrap();
        assert!(matches!(parsed, ParseAttribute::display(_))); let parsed: ParseAttribute = syn::parse_str(r#"ignore = "i have my reasons""#).unwrap();
        assert!(matches!(parsed, ParseAttribute::ignore(_)));

        let parsed: ParseAttribute = syn::parse_str("ignore").unwrap();
        assert!(matches!(parsed, ParseAttribute::ignore(_)));
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

So far, so good, but if you tried to parse multiple attributes then you'll get a failure, We need to be able to parse a comma deleniated set of attributes. And this is how I choose to implement that:

```rust
// File: `cache_diff_derive/src/parse_field.rs`
// Use ...


// Code
// ...
impl ParseAttribute {
    fn from_attrs(attrs: &[syn::Attribute]) -> Result<Vec<ParseAttribute>, syn::Error> {
        let mut attributes = Vec::new();
        for attr in attrs.iter().filter(|attr| attr.path().is_ident(NAMESPACE)) {
            for attribute in attr.parse_args_with(
                syn::punctuated::Punctuated::<ParseAttribute, syn::Token![,]>::parse_terminated,
            )? {
                attributes.push(attribute)
            }
        }

        Ok(attributes)
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Here's a quick test before I circle back and explain what's going on:

```rust
// File: `cache_diff_derive/src/parse_field.rs`
// Use ...


// Code
// ...

#[cfg(test)]
mod tests {
    // Test use
    // ...

    // Test code
    // ...
    #[test]
    fn test_parse_rename_ignore_attribute() {
        let field: syn::Field = syn::parse_quote! {
            #[cache_diff(rename="Ruby version", ignore)]
            name: String
        };

        assert_eq!(
            vec![
                ParseAttribute::rename("Ruby version".to_string()),
                ParseAttribute::ignore("default".to_string()),
            ],
            ParseAttribute::from_attrs(&field.attrs).unwrap()
        );
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

This code pulls out attributes on a field and iterates over them. The `syn` code receives ALL attributes, so we have to filter by our macro's namespace, or else we'll accidentally try to parse things like `serde(...)` attributes from other macros. This will yield a `syn::Attribute`:

```rust
for attr in field
    .attrs
    .iter()
    .filter(|attr| attr.path().is_ident(NAMESPACE))
{
    // ... attr is a syn::Attribute
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

We use the [`syn::Attribute::parse_args_with`](https://docs.rs/syn/latest/syn/struct.Attribute.html#method.parse_args_with) function which takes a parser. We've implemented two parsers so far `KnownAttribute` and `ParseAttribute`. But we need something that can handle a comma separated set of attributes, so we turn to the pre-built `syn::punctuated::Punctuated` parser, which is actually a parser combinator, meaning it takes in other parsers as it's input. In our case we're telling it to build a set of `ParseAttribute` structs, and use commas to separate them. We then call `parse_terminated` on this parser combinator which returns an iterator of item type `ParseAttribute` that we can use to build and return our `Vec<ParseAttribute>`:

```rust
for attribute in attr.parse_args_with(
    syn::punctuated::Punctuated::<ParseAttribute, syn::Token![,]>::parse_terminated,
)? {
    attributes.push(attribute)
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

At this point we've added the ability to extract any cache_diff attributes from a `syn::Field` as a `Vec<ParseAttribute>`, but so far, nothing uses `ParseAttribute` outside of this module. We need to take this information and put it into a `ParseField` to make it useful. Replace this code:

```rust
// File: `cache_diff_derive/src/parse_field.rs`
// Use ...


// Code
// ...
/// Field (i.e. `name: String`) of a container (struct) and its parsed attributes
/// i.e. `#[cache_diff(rename = "Ruby version")]`
#[derive(Debug)]
pub(crate) struct ParseField {
    /// The proc-macro identifier for a field i.e. `name: String` would be a programatic
    /// reference to `name` that can be used along with `quote!` to produce code.
    pub(crate) ident: syn::Ident,
    /// What the user will see when this field differs and invalidates the cache
    /// i.e. `age: usize` will be `"age"`.
    pub(crate) name: String,
}


```

With with these new contents:


```rust
// File: `cache_diff_derive/src/parse_field.rs`
// Use ...


// Code
// ...
/// Field (i.e. `name: String`) of a container (struct) and its parsed attributes
/// i.e. `#[cache_diff(rename = "Ruby version")]`
#[derive(Debug)]
pub(crate) struct ParseField {
    /// The proc-macro identifier for a field i.e. `name: String` would be a programatic
    /// reference to `name` that can be used along with `quote!` to produce code.
    pub(crate) ident: syn::Ident,
    /// What the user will see when this field differs and invalidates the cache
    /// i.e. `age: usize` will be `"age"`.
    pub(crate) name: String,
    /// Whether or not the field is included in the derived diff comparison
    pub(crate) ignore: Option<String>,
    /// The function to use when rendering values on the field
    /// i.e. `age: 42` will be `"42"`
    pub(crate) display: syn::Path,
}


```

We were already storing the ident and desired name of our field, but now we're also capturing if it was ignored or not as well as what function to use for it's display. Since this last value, `display`, isn't optional, we'll need to set it for every field. To help with this, there's a nifty utility function that returns whatever is passed to it we can use as a default [`std::convert::identity`](https://doc.rust-lang.org/std/convert/fn.identity.html). And while we're picking out sensible defaults, if we can detect that a type is a `std::path::PathBuf` then we can go ahead and default to `std::path::Path::display` since we know it does not implement `Display`. To help that detection, add a helper function:

```rust
// File: `cache_diff_derive/src/parse_field.rs`
// Use ...


// Code
// ...
fn is_pathbuf(ty: &syn::Type) -> bool {
    if let syn::Type::Path(type_path) = ty {
        if let Some(segment) = type_path.path.segments.last() {
            return segment.ident == "PathBuf" && segment.arguments == syn::PathArguments::None;
        }
    }
    false
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

This code takes in a `syn::Type`, checks if it's a path to a type and if it is and matches `PathBuf` then it returns true. Perhaps there's a more robust way to do check, if you know one...let me know.

With that helper code in place we can now extract values to build our new `ParseField`. Replace this code:


```rust
// File: `cache_diff_derive/src/parse_field.rs`
// Use ...


// Code
// ...
impl ParseField {
    pub(crate) fn from_field(field: &syn::Field) -> Result<Self, syn::Error> {
        let ident = field.ident.clone().ok_or_else(|| {
            syn::Error::new(
                field.span(),
                format!("{MACRO_NAME} can only be used on structs with named fields"),
            )
        })?;

        let name = ident.to_string().replace("_", " ");

        Ok(ParseField {
            ident,
            name,
        })
    }
}


```

With with these new contents:


```rust
// File: `cache_diff_derive/src/parse_field.rs`
// Use ...


// Code
// ...
impl ParseField {
    pub(crate) fn from_field(field: &syn::Field) -> Result<Self, syn::Error> {
        let ident = field.ident.clone().ok_or_else(|| {
            syn::Error::new(
                field.span(),
                format!("{MACRO_NAME} can only be used on structs with named fields"),
            )
        })?;

        let attributes = ParseAttribute::from_attrs(&field.attrs)?;
        let name = attributes
            .iter()
            .filter_map(|attribute| match attribute {
                ParseAttribute::rename(name) => Some(name.to_owned()),
                _ => None,
            })
            .last()
            .unwrap_or_else(|| ident.to_string().replace("_", " "));
        let display = attributes
            .iter()
            .filter_map(|attribute| match attribute {
                ParseAttribute::display(display_fn) => Some(display_fn.to_owned()),
                _ => None,
            })
            .last()
            .unwrap_or_else(|| {
                if is_pathbuf(&field.ty) {
                    syn::parse_str("std::path::Path::display")
                        .expect("PathBuf::display parses as a syn::Path")
                } else {
                    syn::parse_str("std::convert::identity")
                        .expect("std::convert::identity parses as a syn::Path")
                }
            });

        let ignore = attributes
            .into_iter()
            .filter_map(|attribute| match attribute {
                ParseAttribute::ignore(reason) => Some(reason),
                _ => None,
            })
            .last();

        Ok(ParseField {
            ident,
            name,
            ignore,
            display,
        })
    }
}



```

The code starts off in a similar fashion, but then diverges by building a Vec of `ParseAttributes` that we can iterate through. An eagle-eyed reader might notice that there's nothing preventing two or three attribute declarations via our user like:

```rust
struct Metadata {
    #[cache_diff(rename = "Foo")]
    #[cache_diff(rename = "Bar")]
    #[cache_diff(rename = "Baz", rename = "Ruby Version")]
    version: String
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

If I wanted to be more strict, I could raise a `syn::Error` when an attribute is specified more than once, but in our case, it's simple enough that we'll say that the last one wins. So the above example would be renamed to `"Ruby Version"` and all those other attributes would be no-ops.

Each attribute we support is queried, if it doesn't exist then we set a default and keep going until all information needed to build the struct is present.

It might seem like we added a lot of code, but most of this boils down to:

- Define all valid attributes in a `ParseAttribute` enum with a `KnownAttribute` discriminant
- Implement `syn::parse::Parse` for these enums
- Implement a function that takes in a `syn::Field` and returns `Vec<ParseAttribute>`
- Add any new fields needed to your `ParseField` struct
- Adjust your building functions to use the new attribute information collected.

Sometimes it's easier to  go the other way, by defining the fields you need to for `ParseField` and then figuring out the API you want to make to support it, but from a testing perspective, it's easier to start with smaller parsers and gradually combine them to build bigger ones.


Verify tests are all passing:

```
$ cargo test
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

If your project is failing or if the tests you added didn't run, here's the full project for reference:

<details>
  <summary>Full project</summary>

```
$ exa --tree --git-ignore .
.
├── cache_diff
│  ├── Cargo.toml
│  └── src
│     └── lib.rs
├── cache_diff_derive
│  ├── Cargo.toml
│  └── src
│     ├── lib.rs
│     ├── parse_container.rs
│     └── parse_field.rs
├── Cargo.lock
└── Cargo.toml
$ cat Cargo.toml
[workspace]
members = [
    "cache_diff",
    "cache_diff_derive"
]
resolver = "2"
$ cat cache_diff/Cargo.toml
[package]
name = "cache_diff"
version = "0.1.0"
edition = "2024"

[dependencies]
cache_diff_derive = { version = "0.1.0" , optional = true, path = "../cache_diff_derive" }

[features]
derive = ["dep:cache_diff_derive"]
default = ["derive"]
$ cat cache_diff_derive/Cargo.toml
[package]
name = "cache_diff_derive"
version = "0.1.0"
edition = "2024"

[dependencies]
# Turn Rust code into Tokens
quote = "1.0.37"
# Parse tokens into Rust code
syn = { version = "2.0.83", features = ["extra-traits"] }
proc-macro2 = "1.0.89"
strum = { version = "0.26", features = ["derive"] }
[lib]
proc-macro = true
$ cat cache_diff/src/lib.rs
// File: `cache_diff/src/lib.rs`
//! Cache Diff (derive)
//!
//! Generate the difference between two structs for the purposes of cache invalidation.
//!
//! Example:
//!
//! ```
//! use cache_diff::CacheDiff;
//!
//! #[derive(CacheDiff, Debug)]
//! struct Metadata {
//!     ruby_version: String,
//!     architecture: String,
//! }
//!
//! let diff = Metadata {ruby_version: "3.4.2".to_string(), architecture: "arm64".to_string()}
//!     .diff(&Metadata {ruby_version: "3.3.1".to_string(), architecture: "amd64".to_string()});
//!
//! assert_eq!(
//!     vec!["ruby version (3.3.1 to 3.4.2)".to_string(), "architecture (amd64 to arm64)".to_string()],
//!     diff
//! );
//! ```
pub use cache_diff_derive::CacheDiff;

// Code
pub trait CacheDiff {
    fn diff(&self, old: &Self) -> Vec<String>;
}

#[cfg(test)]
mod tests {
    // Test use
    use super::*;
    // Test code
    struct Metadata {
        ruby_version: String,
        architecture: String,
    }

    impl CacheDiff for Metadata {
        fn diff(&self, old: &Self) -> Vec<String> {
            let mut diff = Vec::new();

            if self.ruby_version != old.ruby_version {
                diff.push(format!("ruby version ({} to {})",
                old.ruby_version,
                self.ruby_version))
            }
            if self.architecture != old.architecture {
                diff.push(
                    format!("architecture ({} to {})",
                    old.architecture,
                    self.architecture)
                )
            }
            diff
        }
    }

    #[test]
    fn test_changed_metadata() {
        let old = Metadata {
            ruby_version: "3.3.1".to_string(),
            architecture: "amd64".to_string()
        };
        let new = Metadata {
            ruby_version: "3.4.2".to_string(),
            architecture: "arm64".to_string()
        };

        assert_eq!(
            vec![
                "ruby version (3.3.1 to 3.4.2)".to_string(),
                "architecture (amd64 to arm64)".to_string()
            ],
            new.diff(&old)
        );
    }

    #[test]
    fn test_unchanged_metadata() {
        let old = Metadata {
            ruby_version: "3.1.4".to_string(),
            architecture: "amd64".to_string()
        };

        let diff = old.diff(&old);
        assert!(
            diff.is_empty(),
            "Expected diff to be empty but is {:?}",
            diff
        );
    }
}
$ cat cache_diff_derive/src/lib.rs
// File: `cache_diff_derive/src/lib.rs`
mod parse_field;
mod parse_container;
use proc_macro::TokenStream;
use parse_container::ParseContainer;
use parse_field::ParseField;

// Code
pub(crate) const NAMESPACE: &str = "cache_diff";
pub(crate) const MACRO_NAME: &str = "CacheDiff";

#[proc_macro_derive(CacheDiff, attributes(cache_diff))]
pub fn cache_diff(item: TokenStream)
    -> TokenStream {
    create_cache_diff(item.into())
        .unwrap_or_else(syn::Error::into_compile_error)
        .into()
}

fn create_cache_diff(item: proc_macro2::TokenStream)
    -> syn::Result<proc_macro2::TokenStream> {
    let derive_input: syn::DeriveInput = syn::parse2(item)?;
    let container = ParseContainer::from_derive_input(&derive_input)?;
    let struct_identifier = &container.ident;

    let mut comparisons = Vec::new();
    for field in container.fields.iter() {
        let ParseField {
            ident,
            name,
            ..
        } = field;

        comparisons.push(quote::quote! {
            if self.#ident != old.#ident {
                differences.push(
                    format!("{name} ({old} to {new})",
                        name = #name,
                        old = &old.#ident,
                        new = &self.#ident,
                    )
                );
            }
        });
    }

    Ok(quote::quote! {
        impl cache_diff::CacheDiff for #struct_identifier {
            fn diff(&self, old: &Self) -> ::std::vec::Vec<String> {
                let mut differences = ::std::vec::Vec::new();
                #(#comparisons)*
                differences
            }
        }
    })
}
$ cat cache_diff_derive/src/parse_field.rs
// File: `cache_diff_derive/src/parse_field.rs`
use crate::MACRO_NAME;
use syn::spanned::Spanned;
use std::str::FromStr;
use strum::IntoEnumIterator;
use crate::NAMESPACE;

// Code
/// Field (i.e. `name: String`) of a container (struct) and its parsed attributes
/// i.e. `#[cache_diff(rename = "Ruby version")]`
#[derive(Debug)]
pub(crate) struct ParseField {
    /// The proc-macro identifier for a field i.e. `name: String` would be a programatic
    /// reference to `name` that can be used along with `quote!` to produce code.
    pub(crate) ident: syn::Ident,
    /// What the user will see when this field differs and invalidates the cache
    /// i.e. `age: usize` will be `"age"`.
    pub(crate) name: String,
    /// Whether or not the field is included in the derived diff comparison
    pub(crate) ignore: Option<String>,
    /// The function to use when rendering values on the field
    /// i.e. `age: 42` will be `"42"`
    pub(crate) display: syn::Path,
}

impl ParseField {
    pub(crate) fn from_field(field: &syn::Field) -> Result<Self, syn::Error> {
        let ident = field.ident.clone().ok_or_else(|| {
            syn::Error::new(
                field.span(),
                format!("{MACRO_NAME} can only be used on structs with named fields"),
            )
        })?;

        let attributes = ParseAttribute::from_attrs(&field.attrs)?;
        let name = attributes
            .iter()
            .filter_map(|attribute| match attribute {
                ParseAttribute::rename(name) => Some(name.to_owned()),
                _ => None,
            })
            .last()
            .unwrap_or_else(|| ident.to_string().replace("_", " "));
        let display = attributes
            .iter()
            .filter_map(|attribute| match attribute {
                ParseAttribute::display(display_fn) => Some(display_fn.to_owned()),
                _ => None,
            })
            .last()
            .unwrap_or_else(|| {
                if is_pathbuf(&field.ty) {
                    syn::parse_str("std::path::Path::display")
                        .expect("PathBuf::display parses as a syn::Path")
                } else {
                    syn::parse_str("std::convert::identity")
                        .expect("std::convert::identity parses as a syn::Path")
                }
            });

        let ignore = attributes
            .into_iter()
            .filter_map(|attribute| match attribute {
                ParseAttribute::ignore(reason) => Some(reason),
                _ => None,
            })
            .last();

        Ok(ParseField {
            ident,
            name,
            ignore,
            display,
        })
    }
}


/// A single attribute
#[derive(strum::EnumDiscriminants, Debug, PartialEq)]
#[strum_discriminants(derive(strum::EnumIter, strum::Display, strum::EnumString))]
#[strum_discriminants(name(KnownAttribute))]
enum ParseAttribute {
    #[allow(non_camel_case_types)]
    rename(String), // #[cache_diff(rename="...")]
    #[allow(non_camel_case_types)]
    display(syn::Path), // #[cache_diff(display=<function>)]
    #[allow(non_camel_case_types)]
    ignore(String), // #[cache_diff(ignore)]
}

impl syn::parse::Parse for KnownAttribute {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let identity: syn::Ident = input.parse()?;
        KnownAttribute::from_str(&identity.to_string()).map_err(|_| {
            syn::Error::new(
                identity.span(),
                format!(
                    "Unknown {NAMESPACE} attribute: `{identity}`. Must be one of {valid_keys}",
                    valid_keys = KnownAttribute::iter()
                        .map(|key| format!("`{key}`"))
                        .collect::<Vec<String>>()
                        .join(", ")
                ),
            )
        })
    }
}

impl syn::parse::Parse for ParseAttribute {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let key: KnownAttribute = input.parse()?;

        match key {
            KnownAttribute::rename => {
                input.parse::<syn::Token![=]>()?;
                Ok(ParseAttribute::rename(
                    input.parse::<syn::LitStr>()?.value(),
                ))
            }
            KnownAttribute::display => {
                input.parse::<syn::Token![=]>()?;
                Ok(ParseAttribute::display(input.parse()?))
            }
            KnownAttribute::ignore => {
                if input.peek(syn::Token![=]) {
                    input.parse::<syn::Token![=]>()?;
                    Ok(ParseAttribute::ignore(
                        input.parse::<syn::LitStr>()?.value(),
                    ))
                } else {
                    Ok(ParseAttribute::ignore("default".to_string()))
                }
            }
        }
    }
}

impl ParseAttribute {
    fn from_attrs(attrs: &[syn::Attribute]) -> Result<Vec<ParseAttribute>, syn::Error> {
        let mut attributes = Vec::new();
        for attr in attrs.iter().filter(|attr| attr.path().is_ident(NAMESPACE)) {
            for attribute in attr.parse_args_with(
                syn::punctuated::Punctuated::<ParseAttribute, syn::Token![,]>::parse_terminated,
            )? {
                attributes.push(attribute)
            }
        }

        Ok(attributes)
    }
}

fn is_pathbuf(ty: &syn::Type) -> bool {
    if let syn::Type::Path(type_path) = ty {
        if let Some(segment) = type_path.path.segments.last() {
            return segment.ident == "PathBuf" && segment.arguments == syn::PathArguments::None;
        }
    }
    false
}

#[cfg(test)]
mod tests {
    // Test use
    use super::*;
    // Test code
    #[test]
    fn test_parse_field_plain() {
        let field: syn::Field = syn::parse_quote! {
            ruby_version: String
        };

        let parsed = ParseField::from_field(&field).unwrap();
        assert_eq!("ruby version".to_string(), parsed.name);
    }

    #[test]
    fn test_requires_named_struct() {
        let field: syn::Field = syn::parse_quote! {()};

        let result = ParseField::from_field(&field);
        assert!(result.is_err(), "Expected an error, got {:?}", result);
        assert_eq!(
            format!("{}", result.err().unwrap()),
            r#"CacheDiff can only be used on structs with named fields"#
        );
    }

    #[test]
    fn test_known_attributes() {
        let parsed: KnownAttribute = syn::parse_str("rename").unwrap();
        assert_eq!(KnownAttribute::rename, parsed);

        let parsed: KnownAttribute = syn::parse_str("ignore").unwrap();
        assert_eq!(KnownAttribute::ignore, parsed);

        let parsed: KnownAttribute = syn::parse_str("display").unwrap();
        assert_eq!(KnownAttribute::display, parsed);

        let result: Result<KnownAttribute, syn::Error> = syn::parse_str("unknown");
        assert!(result.is_err(), "Expected an error, got {:?}", result);
        assert_eq!(
            format!("{}", result.err().unwrap()),
            r#"Unknown cache_diff attribute: `unknown`. Must be one of `rename`, `display`, `ignore`"#
        );
    }

    #[test]
    fn test_parse_attributes() {
        let parsed: ParseAttribute = syn::parse_str(r#"rename = "Ruby version""#).unwrap();
        assert_eq!(ParseAttribute::rename("Ruby version".to_string()), parsed);

        let parsed: ParseAttribute = syn::parse_str(r#"display= my_function"#).unwrap();
        assert!(matches!(parsed, ParseAttribute::display(_))); let parsed: ParseAttribute = syn::parse_str(r#"ignore = "i have my reasons""#).unwrap();
        assert!(matches!(parsed, ParseAttribute::ignore(_)));

        let parsed: ParseAttribute = syn::parse_str("ignore").unwrap();
        assert!(matches!(parsed, ParseAttribute::ignore(_)));
    }

    #[test]
    fn test_parse_rename_ignore_attribute() {
        let field: syn::Field = syn::parse_quote! {
            #[cache_diff(rename="Ruby version", ignore)]
            name: String
        };

        assert_eq!(
            vec![
                ParseAttribute::rename("Ruby version".to_string()),
                ParseAttribute::ignore("default".to_string()),
            ],
            ParseAttribute::from_attrs(&field.attrs).unwrap()
        );
    }
}
$ cat cache_diff_derive/src/parse_container.rs
// File: `cache_diff_derive/src/parse_container.rs`
use crate::parse_field::ParseField;
use crate::MACRO_NAME;

// Code
/// Container (i.e. struct Metadata { ... }) and its parsed attributes
/// i.e. `#[cache_diff( ... )]`
#[derive(Debug)]
pub(crate) struct ParseContainer {
    /// The proc-macro identifier for a container i.e. `struct Metadata { }` would be a programatic
    /// reference to `Metadata` that can be used along with `quote!` to produce code.
    pub(crate) ident: syn::Ident,
    /// Fields (i.e. `name: String`) and their associated attributes i.e. `#[cache_diff(...)]`
    pub(crate) fields: Vec<ParseField>,
}

impl ParseContainer {
    pub(crate) fn from_derive_input(input: &syn::DeriveInput) -> Result<Self, syn::Error> {
        let ident = input.ident.clone();
        let fields = match input.data {
            syn::Data::Struct(syn::DataStruct {
                fields: syn::Fields::Named(syn::FieldsNamed { ref named, .. }),
                ..
            }) => named,
            _ => {
                return Err(syn::Error::new(
                    ident.span(),
                    format!("{MACRO_NAME} can only be used on named structs"),
                ))
            }
        }
        .into_iter()
        .map(ParseField::from_field)
        .collect::<Result<Vec<ParseField>, syn::Error>>()?;

        Ok(ParseContainer { ident, fields })
    }
}

#[cfg(test)]
mod tests {
    // Test use
    use super::*;
    // Test code
    #[test]
    fn test_parses() {
        let container = ParseContainer::from_derive_input(&syn::parse_quote! {
            struct Metadata {
                version: String
            }
        })
        .unwrap();
        assert_eq!(1, container.fields.len());

        let container = ParseContainer::from_derive_input(&syn::parse_quote! {
            struct Metadata {
                version: String,
                checksum: String
            }
        })
        .unwrap();
        assert_eq!(2, container.fields.len());
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->
</details>

We're done with the field modifications. We need to adjust our container code to add a container attribute, and then our final `lib.rs` code needs to use all this tasty info we just added.
## Add a container attribute


Like we did with fields, we'll define an enum to hold each container attribute variant.

```rust

// File: `cache_diff_derive/src/parse_container.rs`
// Use ...
use std::str::FromStr;
use strum::IntoEnumIterator;

// Code
// ...
/// A single attribute
#[derive(strum::EnumDiscriminants, Debug, PartialEq)]
#[strum_discriminants(derive(strum::EnumIter, strum::Display, strum::EnumString))]
#[strum_discriminants(name(KnownAttribute))]
enum ParseAttribute {
    #[allow(non_camel_case_types)]
    custom(syn::Path), // #[cache_diff(custom=<function>)]
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

We will go ahead and add an implementation of `syn::parse::Parse` for `KnownAttribute`, it's virtually identical:

```rust
// File: `cache_diff_derive/src/parse_container.rs`
// Use ...
use crate::NAMESPACE;

// Code
// ...
impl syn::parse::Parse for KnownAttribute {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let identity: syn::Ident = input.parse()?;
        KnownAttribute::from_str(&identity.to_string()).map_err(|_| {
            syn::Error::new(
                identity.span(),
                format!(
                    "Unknown {NAMESPACE} attribute: `{identity}`. Must be one of {valid_keys}",
                    valid_keys = KnownAttribute::iter()
                        .map(|key| format!("`{key}`"))
                        .collect::<Vec<String>>()
                        .join(", ")
                ),
            )
        })
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

The turning an input into a vector of parsed attributes looks pretty similar as well:


```rust
// File: `cache_diff_derive/src/parse_container.rs`
// Use ...


// Code
// ...
impl ParseAttribute {
    fn from_attrs(attrs: &[syn::Attribute]) -> Result<Vec<ParseAttribute>, syn::Error> {
        let mut attributes = Vec::new();
        for attr in attrs.iter().filter(|attr| attr.path().is_ident(NAMESPACE)) {
            for attribute in attr.parse_args_with(
                syn::punctuated::Punctuated::<ParseAttribute, syn::Token![,]>::parse_terminated,
            )? {
                attributes.push(attribute)
            }
        }

        Ok(attributes)
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

The actual parse code is slightly different, but it should seem like a familiar pattern:

```rust
// File: `cache_diff_derive/src/parse_container.rs`
// Use ...


// Code
// ...
impl syn::parse::Parse for ParseAttribute {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let key: KnownAttribute = input.parse()?;
        input.parse::<syn::Token![=]>()?;
        match key {
            KnownAttribute::custom => Ok(ParseAttribute::custom(input.parse()?)),
        }
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Verify your intuition (and my claims) with some tests:

```rust
// File: `cache_diff_derive/src/parse_container.rs`
// Use ...


// Code
// ...

#[cfg(test)]
mod tests {
    // Test use
    // ...

    // Test code
    // ...
    #[test]
    fn test_known_attributes() {
        let attribute: KnownAttribute = syn::parse_str("custom").unwrap();
        assert_eq!(KnownAttribute::custom, attribute);
    }

    #[test]
    fn test_parse_attribute() {
        let attribute: ParseAttribute = syn::parse_str("custom = my_function").unwrap();
        assert!(matches!(attribute, ParseAttribute::custom(_)));

        let result: Result<ParseAttribute, syn::Error> = syn::parse_str("unknown");
        assert!(result.is_err(), "Expected an error, got {:?}", result);
        assert_eq!(
            r"Unknown cache_diff attribute: `unknown`. Must be one of `custom`",
            format!("{}", result.err().unwrap()),
        );
    }

    #[test]
    fn test_custom_parse_attribute() {
        let input: syn::DeriveInput = syn::parse_quote! {
            #[cache_diff(custom = my_function)]
            struct Metadata {
                name: String
            }
        };

        assert!(matches!(
            ParseAttribute::from_attrs(&input.attrs)
                .unwrap()
                .first(),
            Some(ParseAttribute::custom(_))
        ));
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Verify they work, and now you shouldn't see any warnings:

```
$ cargo test
   Compiling cache_diff_derive v0.1.0 (/private/var/folders/yr/yytf3z3n3q336f1tj2b2j0gw0000gn/T/d20250304-34020-kjphav/cache_diff/cache_diff_derive)
warning: fields `ignore` and `display` are never read
  --> cache_diff_derive/src/parse_field.rs:20:16
   |
12 | pub(crate) struct ParseField {
   |                   ---------- fields in this struct
...
20 |     pub(crate) ignore: Option<String>,
   |                ^^^^^^
...
23 |     pub(crate) display: syn::Path,
   |                ^^^^^^^
   |
   = note: `ParseField` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis
   = note: `#[warn(dead_code)]` on by default

warning: associated function `from_attrs` is never used
  --> cache_diff_derive/src/parse_container.rs:71:8
   |
70 | impl ParseAttribute {
   | ------------------- associated function in this implementation
71 |     fn from_attrs(attrs: &[syn::Attribute]) -> Result<Vec<ParseAttribute>, syn::Error> {
   |        ^^^^^^^^^^

warning: `cache_diff_derive` (lib) generated 2 warnings
   Compiling cache_diff v0.1.0 (/private/var/folders/yr/yytf3z3n3q336f1tj2b2j0gw0000gn/T/d20250304-34020-kjphav/cache_diff/cache_diff)
warning: `cache_diff_derive` (lib test) generated 1 warning (1 duplicate)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.64s
     Running unittests src/lib.rs (target/debug/deps/cache_diff-7c1f428e3c9023d2)

running 2 tests
test tests::test_unchanged_metadata ... ok
test tests::test_changed_metadata ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/lib.rs (target/debug/deps/cache_diff_derive-ca382734a8ccd4f5)

running 9 tests
test parse_container::tests::test_known_attributes ... ok
test parse_field::tests::test_requires_named_struct ... ok
test parse_container::tests::test_parse_attribute ... ok
test parse_field::tests::test_known_attributes ... ok
test parse_field::tests::test_parse_attributes ... ok
test parse_container::tests::test_custom_parse_attribute ... ok
test parse_field::tests::test_parse_rename_ignore_attribute ... ok
test parse_field::tests::test_parse_field_plain ... ok
test parse_container::tests::test_parses ... ok

test result: ok. 9 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests cache_diff

running 1 test
test cache_diff/src/lib.rs - (line 8) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.25s

   Doc-tests cache_diff_derive

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Now let's wire it up. Start of by adding a place to store our attribute on the container. Replace this code:


```rust
// File: `cache_diff_derive/src/parse_container.rs`
// Use ...


// Code
// ...
/// Container (i.e. struct Metadata { ... }) and its parsed attributes
/// i.e. `#[cache_diff( ... )]`
#[derive(Debug)]
pub(crate) struct ParseContainer {
    /// The proc-macro identifier for a container i.e. `struct Metadata { }` would be a programatic
    /// reference to `Metadata` that can be used along with `quote!` to produce code.
    pub(crate) ident: syn::Ident,
    /// Fields (i.e. `name: String`) and their associated attributes i.e. `#[cache_diff(...)]`
    pub(crate) fields: Vec<ParseField>,
}


```

With with these new contents:


```rust
// File: `cache_diff_derive/src/parse_container.rs`
// Use ...


// Code
// ...
/// Container (i.e. struct Metadata { ... }) and its parsed attributes
/// i.e. `#[cache_diff( ... )]`
#[derive(Debug)]
pub(crate) struct ParseContainer {
    /// The proc-macro identifier for a container i.e. `struct Metadata { }` would be a programatic
    /// reference to `Metadata` that can be used along with `quote!` to produce code.
    pub(crate) ident: syn::Ident,
    /// An optional path to a custom diff function
    /// Set via attribute on the container i.e. `#[cache_diff(custom = <function>)]`
    pub(crate) custom: Option<syn::Path>,
    /// Fields (i.e. `name: String`) and their associated attributes i.e. `#[cache_diff(...)]`
    pub(crate) fields: Vec<ParseField>,
}


```

Then update the logic for building the container. Replace this code:

```rust
// File: `cache_diff_derive/src/parse_container.rs`
// Use ...


// Code
// ...
impl ParseContainer {
    pub(crate) fn from_derive_input(input: &syn::DeriveInput) -> Result<Self, syn::Error> {
        let ident = input.ident.clone();
        let fields = match input.data {
            syn::Data::Struct(syn::DataStruct {
                fields: syn::Fields::Named(syn::FieldsNamed { ref named, .. }),
                ..
            }) => named,
            _ => {
                return Err(syn::Error::new(
                    ident.span(),
                    format!("{MACRO_NAME} can only be used on named structs"),
                ))
            }
        }
        .into_iter()
        .map(ParseField::from_field)
        .collect::<Result<Vec<ParseField>, syn::Error>>()?;

        Ok(ParseContainer { ident, fields })
    }
}


```

With with these new contents:


```rust
// File: `cache_diff_derive/src/parse_container.rs`
// Use ...


// Code
// ...
impl ParseContainer {
    pub(crate) fn from_derive_input(input: &syn::DeriveInput) -> Result<Self, syn::Error> {
        let ident = input.ident.clone();
        let attributes = ParseAttribute::from_attrs(&input.attrs)?;
        let custom = attributes
            .into_iter()
            .map(|attribute| match attribute {
                ParseAttribute::custom(path) => path,
            })
            .last();
        let fields = match input.data {
            syn::Data::Struct(syn::DataStruct {
                fields: syn::Fields::Named(syn::FieldsNamed { ref named, .. }),
                ..
            }) => named,
            _ => {
                return Err(syn::Error::new(
                    ident.span(),
                    format!("{MACRO_NAME} can only be used on named structs"),
                ))
            }
        }
        .into_iter()
        .map(ParseField::from_field)
        .collect::<Result<Vec<ParseField>, syn::Error>>()?;

        if let Some(field) = fields
            .iter()
            .find(|field| matches!(field.ignore.as_deref(), Some("custom")))
        {
            if custom.is_none() {
                return Err(syn::Error::new(ident.span(),
                            format!(
                                "field `{field}` on {container} marked ignored as custom, but no `#[{NAMESPACE}(custom = <function>)]` found on `{container}`",
                                field = field.ident,
                                container = &ident,
                            )));
            }
        }

        if fields.iter().any(|f| f.ignore.is_none()) {
            Ok(ParseContainer {
                ident,
                fields,
                custom,
            })
        } else {
            Err(syn::Error::new(ident.span(), format!("No fields to compare for {MACRO_NAME}, ensure struct has at least one named field that isn't `{NAMESPACE}(ignore)`")))
        }
    }
}


```

The are two new things here, one of them is small and expected:

```rust
let custom = attributes
    .into_iter()
    .map(|attribute| match attribute {
        ParseAttribute::custom(path) => path,
    })
    .last();
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

This is where we're pulling out the attribute information and querying it, similar to how we did it with the `ParseField`. Hopefully you expected that addition. The other is: A bunch of manual error handling. For example:

```rust
if let Some(field) = fields
    .iter()
    .find(|field| matches!(field.ignore.as_deref(), Some("custom")))
{
    if custom.is_none() {
        return Err(syn::Error::new(ident.span(),
                    format!(
                        "field `{field}` on {container} marked ignored as custom, but no `#[{NAMESPACE}(custom = <function>)]` found on `{container}`",
                        field = field.ident,
                        container = &ident,
                    )));
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Previously when I added the ability to set a field as ignored with a reason, it gave us the ability to add a preference signal that did something meaningful. In this case we are saying that if the user adds a `#[cache_diff(ignore = "custom")]` to one of their fields, they MUST also add a `#[cache_diff(custom = <function>)]` to the container. Because proc macros make it faster for the end user to generate and manipulate code, it makes it faster for them to make mistakes too. You could imagaine a scenario where they're playing around with configuration options and they accidentally delete the container attribute line, and it's not caught in code review and the linter isn't loud enough, so they deploy with code that looks correct but isn't. The nice thing about adding this error here, is that when the user tries to compile their code with invalid state, it's not representable and they get a clear error explaining what went wrong and how to fix it. Coming from (such a flexible and dynamic language as) Ruby, these defensive codeing practices are second nature to me. [A talk by Avdii back from 2011 comes to mind](https://www.youtube.com/watch?v=t8s2MqnDPD8). You don't need to pre-think every possible thing a coder can do wrong with your library, but it's worth both thinking about it ahead of your first proc-macro release, as well as being on the lookout for examples of incorrect usage from other devs and from your own code and notes.


The other error is here:

```rust
if fields.iter().any(|f| f.ignore.is_none()) {
    Ok(ParseContainer {
        ident,
        fields,
        custom,
    })
} else {
    Err(syn::Error::new(ident.span(), format!("No fields to compare for {MACRO_NAME}, ensure struct has at least one named field that isn't `{NAMESPACE}(ignore)`")))
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

If someone tries to use the macro on an empty struct or accidentally ignores all the fields, then I don't want the derive code to compile. If someone has a legitimate use for a type that is `impl CacheDiff` but always returns an empty difference set, that's fine...but I won't help them construct such an abomination (i.e. I'm not blocking them from implementing it manually, only blocking it via a derive macro). Whenever I write reflection code, I like to have a strong sense of what code paths should be encouraged, which should be allowable but discouraged, and which should be impossible. I also believe that many programmers have more smarts than empathy and thanks to Turing completeness, that means statements like "I cannot imagine a reason why anyone would want to X," may be due to lack of imagination, rather than a lack of a good reason for doing that thing.

Taking these two errors out doesn't change much, but I consider the error experience, how our interfaces behave in failure scenarios, to be a true test of quality software design. Even better design, allows us to assert those failure scenarios via tests:

```rust
// File: `cache_diff_derive/src/parse_container.rs`
// Use ...


// Code
// ...

#[cfg(test)]
mod tests {
    // Test use
    // ...

    // Test code
    // ...
    #[test]
    fn test_no_fields() {
        let result = ParseContainer::from_derive_input(&syn::parse_quote! {
            struct Metadata { }
        });
        assert!(result.is_err(), "Expected an error, got {:?}", result);
        assert_eq!(
            format!("{}", result.err().unwrap()),
            r#"No fields to compare for CacheDiff, ensure struct has at least one named field that isn't `cache_diff(ignore)`"#
        );
    }

    #[test]
    fn test_all_ignored() {
        let result = ParseContainer::from_derive_input(&syn::parse_quote! {
            struct Metadata {
                #[cache_diff(ignore)]
                version: String
            }
        });
        assert!(result.is_err(), "Expected an error, got {:?}", result);
        assert_eq!(
            format!("{}", result.err().unwrap()),
            r#"No fields to compare for CacheDiff, ensure struct has at least one named field that isn't `cache_diff(ignore)`"#
        );
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

With all of this in place, it's time to put a ribbon on it and tie it all together. In the next section we'll use our newly defined field and container attributes in the proc macro output.
## Proc, meet macro (with attributes)

With the parsing logic contained within `ParseContainer` and `ParseField` we can focus on implementing the core logic of our macro. Replace this code:

```rust
// File: `cache_diff_derive/src/lib.rs`
// Mod ...

// Use ...


// Code
// ...
fn create_cache_diff(item: proc_macro2::TokenStream)
    -> syn::Result<proc_macro2::TokenStream> {
    let derive_input: syn::DeriveInput = syn::parse2(item)?;
    let container = ParseContainer::from_derive_input(&derive_input)?;
    let struct_identifier = &container.ident;

    let mut comparisons = Vec::new();
    for field in container.fields.iter() {
        let ParseField {
            ident,
            name,
            ..
        } = field;

        comparisons.push(quote::quote! {
            if self.#ident != old.#ident {
                differences.push(
                    format!("{name} ({old} to {new})",
                        name = #name,
                        old = &old.#ident,
                        new = &self.#ident,
                    )
                );
            }
        });
    }

    Ok(quote::quote! {
        impl cache_diff::CacheDiff for #struct_identifier {
            fn diff(&self, old: &Self) -> ::std::vec::Vec<String> {
                let mut differences = ::std::vec::Vec::new();
                #(#comparisons)*
                differences
            }
        }
    })
}


```

With with these new contents:


```rust
// File: `cache_diff_derive/src/lib.rs`
// Mod ...

// Use ...


// Code
// ...
fn create_cache_diff(item: proc_macro2::TokenStream) -> syn::Result<proc_macro2::TokenStream> {
    let ParseContainer {
        ident,
        custom,
        fields,
    } = ParseContainer::from_derive_input(&syn::parse2(item)?)?;

    let custom_diff = if let Some(ref custom_fn) = custom {
        quote::quote! {
            let custom_diff = #custom_fn(old, self);
            for diff in &custom_diff {
                differences.push(diff.to_string())
            }
        }
    } else {
        quote::quote! {}
    };

    let mut comparisons = Vec::new();
    for field in fields.iter() {
        let ParseField {
            ident,
            name,
            ignore,
            display,
        } = field;

        if ignore.is_none() {
            comparisons.push(quote::quote! {
                if self.#ident != old.#ident {
                    differences.push(
                        format!("{name} ({old} to {new})",
                            name = #name,
                            old = #display(&old.#ident),
                            new = #display(&self.#ident)
                        )
                    );
                }
            });
        }
    }

    Ok(quote::quote! {
        impl cache_diff::CacheDiff for #ident {
            fn diff(&self, old: &Self) -> ::std::vec::Vec<String> {
                let mut differences = ::std::vec::Vec::new();
                #custom_diff
                #(#comparisons)*
                differences
            }
        }
    })
}


```

One thing to call out here is that I'm using `::std::vec::Vec<String>` this is because the environment where the generated code will live is not "hygenic." The [rust refernce](https://doc.rust-lang.org/reference/procedural-macros.html#procedural-macro-hygiene) says more. But basically if you used `Vec` then the calling code could change the behavior of your output by accident if they `use some_other_thing as Vec`. So to avoid ambiguity, we use full paths and start them with `::` (otherwise someone could `use other_thing as std`).

The logic inside of the function is similar to what we saw before. Pull out values from parsed token stream using `syn`. And those values to generate rust code with `quote`. Like before, we're going to write some doctests that use our features like a user would. Beyond convincing you that the code we wrote works, this documentation will be easy to find for anyone using the macro.

I like to make one example per (major) feature and if possible, and use something that's as close to the real-world reason why I added the feature to demonstrate it. I wrote a [book on contributing to open source](http://howtoopensource.dev/), and in the documentation chapter where we document code someone else wrote, I stressed that documentation should help answer the question "why does this (feature) exist." It's better to have docs that say how to florp a floobinator (humerous nonsense), but if the developer reading it has no idea what that means, they won't retain the information for when they need it. Here's the ignore docs:

```rust
// File: `cache_diff/src/lib.rs`
// Module docs ...
//! ## Ignore attributes
//!
//! If the struct contains fields that should not be included in the diff comparison, you can ignore them:
//!
//! ```rust
//! use cache_diff::CacheDiff;
//!
//! #[derive(CacheDiff)]
//! struct Metadata {
//!     version: String,
//!
//!     #[cache_diff(ignore)]
//!     changed_by: String
//! }
//! let now = Metadata { version: "3.4.0".to_string(), changed_by: "Alice".to_string() };
//! let diff = now.diff(&Metadata { version: now.version.clone(), changed_by: "Bob".to_string() });
//!
//! assert!(diff.is_empty());
//! ```
// Use ...


// Code
// ...
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Rename docs:

```rust
// File: `cache_diff/src/lib.rs`
// Module docs ...
//! ## Rename attributes
//!
//! If your field name is not descriptive enough, you can rename it:
//!
//! ```rust
//! use cache_diff::CacheDiff;
//!
//! #[derive(CacheDiff)]
//! struct Metadata {
//!     #[cache_diff(rename="Ruby version")]
//!     version: String,
//! }
//! let now = Metadata { version: "3.4.0".to_string() };
//! let diff = now.diff(&Metadata { version: "3.3.0".to_string() });
//!
//! assert_eq!("Ruby version (3.3.0 to 3.4.0)", diff.join(" "));
//! ```
//!
// Use ...


// Code
// ...
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Display docs:

```rust
// File: `cache_diff/src/lib.rs`
// Module docs ...
//! ## Handle structs missing display
//!
//! Not all structs implement the [`Display`](std::fmt::Display) trait, for example [`std::path::PathBuf`](std::path::PathBuf) requires that you call `display()` on it.
//!
//! The `#[derive(CacheDiff)]` macro will automatically handle the following conversions for you:
//!
//! - `std::path::PathBuf` (via [`std::path::Path::display`](std::path::Path::display))
//!
//! However, if you have a custom struct that does not implement [`Display`](std::fmt::Display), you can specify a function to call instead:
//!
//! ```rust
//! use cache_diff::CacheDiff;
//!
//! #[derive(CacheDiff)]
//! struct Metadata {
//!     #[cache_diff(display = my_function)]
//!     version: NoDisplay,
//! }
//!
//! #[derive(PartialEq)]
//! struct NoDisplay(String);
//! fn my_function(s: &NoDisplay) -> String {
//!     format!("custom {}", s.0)
//! }
//!
//! let now = Metadata { version: NoDisplay("3.4.0".to_string())};
//! let diff = now.diff(&Metadata { version: NoDisplay("3.3.0".to_string())});
//!
//! assert_eq!("version (custom 3.3.0 to custom 3.4.0)", diff.join(" "));
//! ```
//!
// Use ...


// Code
// ...
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Custom function docs:

```rust
// File: `cache_diff/src/lib.rs`
// Module docs ...
//! ## Customize one or more field differences
//!
//! You can provide a custom implementation for a diffing a subset of fields without having to roll your own implementation.
//!
//! ### Custom logic for one field example
//!
//! Here's an example where someone wants to bust the cache after N cache calls. Everything else other than `cache_usage_count` can be derived. If you want to keep the existing derived difference checks, but add on a custom one you can do it like this:
//!
//! ```rust
//! use cache_diff::CacheDiff;
//! const MAX: f32 = 200.0;
//!
//! #[derive(Debug, CacheDiff)]
//! #[cache_diff(custom = diff_cache_usage_count)]
//! pub(crate) struct Metadata {
//!     #[cache_diff(ignore = "custom")]
//!     cache_usage_count: f32,
//!
//!     binary_version: String,
//!     target_arch: String,
//!     os_distribution: String,
//!     os_version: String,
//! }
//!
//! fn diff_cache_usage_count(_old: &Metadata, now: &Metadata) -> Vec<String> {
//!     let Metadata {
//!         cache_usage_count,
//!         binary_version: _,
//!         target_arch: _,
//!         os_distribution: _,
//!         os_version: _,
//!     } = now;
//!
//!     if cache_usage_count > &MAX {
//!         vec![format!("Cache count ({}) exceeded limit {MAX}", cache_usage_count)]
//!     } else {
//!         Vec::new()
//!     }
//! }
//! ```
//!
//! In this example, four fields are derived automatically, saving us time, while one field is custom
//! using the `#[cache_diff(custom = diff_cache_usage_count)]` attribute on the struct. This tells
//! [CacheDiff] to call this function and pass in the old and current values. It expects a vector
//! with some strings if there is a difference and an empty vector if there are none.
//!
//! Don't forget to `#[cache_diff(ignore = "custom")]` any fields you're implementing yourself. You can also use this feature to
//! combine several fields into a single diff output, for example using the previous struct, if
//! you only wanted to have one output for a combined `os_distribution` and `os_version` in one output
//! like "OS (ubuntu-22 to ubuntu-24)". Alternatively, you can use <https://github.com/schneems/magic_migrate> to
//! re-arrange your struct to only have one field with a custom display.
// Use ...


// Code
// ...
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

```
$ cargo clippy
   Compiling cache_diff_derive v0.1.0 (/private/var/folders/yr/yytf3z3n3q336f1tj2b2j0gw0000gn/T/d20250304-34020-kjphav/cache_diff/cache_diff_derive)
    Checking cache_diff v0.1.0 (/private/var/folders/yr/yytf3z3n3q336f1tj2b2j0gw0000gn/T/d20250304-34020-kjphav/cache_diff/cache_diff)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.51s
$ cargo test
   Compiling cache_diff_derive v0.1.0 (/private/var/folders/yr/yytf3z3n3q336f1tj2b2j0gw0000gn/T/d20250304-34020-kjphav/cache_diff/cache_diff_derive)
   Compiling cache_diff v0.1.0 (/private/var/folders/yr/yytf3z3n3q336f1tj2b2j0gw0000gn/T/d20250304-34020-kjphav/cache_diff/cache_diff)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.68s
     Running unittests src/lib.rs (target/debug/deps/cache_diff-7c1f428e3c9023d2)

running 2 tests
test tests::test_unchanged_metadata ... ok
test tests::test_changed_metadata ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/lib.rs (target/debug/deps/cache_diff_derive-ca382734a8ccd4f5)

running 11 tests
test parse_container::tests::test_known_attributes ... ok
test parse_field::tests::test_known_attributes ... ok
test parse_container::tests::test_no_fields ... ok
test parse_field::tests::test_parse_attributes ... ok
test parse_container::tests::test_parse_attribute ... ok
test parse_field::tests::test_parse_field_plain ... ok
test parse_container::tests::test_custom_parse_attribute ... ok
test parse_field::tests::test_parse_rename_ignore_attribute ... ok
test parse_container::tests::test_all_ignored ... ok
test parse_field::tests::test_requires_named_struct ... ok
test parse_container::tests::test_parses ... ok

test result: ok. 11 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests cache_diff

running 5 tests
test cache_diff/src/lib.rs - (line 101) ... ok
test cache_diff/src/lib.rs - (line 29) ... ok
test cache_diff/src/lib.rs - (line 72) ... ok
test cache_diff/src/lib.rs - (line 8) ... ok
test cache_diff/src/lib.rs - (line 48) ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.72s

   Doc-tests cache_diff_derive

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

If your project is failing or if the tests you added didn't run, here's the full project for reference:

<details>
  <summary>Full project</summary>

```
$ exa --tree --git-ignore .
.
├── cache_diff
│  ├── Cargo.toml
│  └── src
│     └── lib.rs
├── cache_diff_derive
│  ├── Cargo.toml
│  └── src
│     ├── lib.rs
│     ├── parse_container.rs
│     └── parse_field.rs
├── Cargo.lock
└── Cargo.toml
$ cat Cargo.toml
[workspace]
members = [
    "cache_diff",
    "cache_diff_derive"
]
resolver = "2"
$ cat cache_diff/Cargo.toml
[package]
name = "cache_diff"
version = "0.1.0"
edition = "2024"

[dependencies]
cache_diff_derive = { version = "0.1.0" , optional = true, path = "../cache_diff_derive" }

[features]
derive = ["dep:cache_diff_derive"]
default = ["derive"]
$ cat cache_diff_derive/Cargo.toml
[package]
name = "cache_diff_derive"
version = "0.1.0"
edition = "2024"

[dependencies]
# Turn Rust code into Tokens
quote = "1.0.37"
# Parse tokens into Rust code
syn = { version = "2.0.83", features = ["extra-traits"] }
proc-macro2 = "1.0.89"
strum = { version = "0.26", features = ["derive"] }
[lib]
proc-macro = true
$ cat cache_diff/src/lib.rs
// File: `cache_diff/src/lib.rs`
//! Cache Diff (derive)
//!
//! Generate the difference between two structs for the purposes of cache invalidation.
//!
//! Example:
//!
//! ```
//! use cache_diff::CacheDiff;
//!
//! #[derive(CacheDiff, Debug)]
//! struct Metadata {
//!     ruby_version: String,
//!     architecture: String,
//! }
//!
//! let diff = Metadata {ruby_version: "3.4.2".to_string(), architecture: "arm64".to_string()}
//!     .diff(&Metadata {ruby_version: "3.3.1".to_string(), architecture: "amd64".to_string()});
//!
//! assert_eq!(
//!     vec!["ruby version (3.3.1 to 3.4.2)".to_string(), "architecture (amd64 to arm64)".to_string()],
//!     diff
//! );
//! ```

//! ## Ignore attributes
//!
//! If the struct contains fields that should not be included in the diff comparison, you can ignore them:
//!
//! ```rust
//! use cache_diff::CacheDiff;
//!
//! #[derive(CacheDiff)]
//! struct Metadata {
//!     version: String,
//!
//!     #[cache_diff(ignore)]
//!     changed_by: String
//! }
//! let now = Metadata { version: "3.4.0".to_string(), changed_by: "Alice".to_string() };
//! let diff = now.diff(&Metadata { version: now.version.clone(), changed_by: "Bob".to_string() });
//!
//! assert!(diff.is_empty());
//! ```

//! ## Rename attributes
//!
//! If your field name is not descriptive enough, you can rename it:
//!
//! ```rust
//! use cache_diff::CacheDiff;
//!
//! #[derive(CacheDiff)]
//! struct Metadata {
//!     #[cache_diff(rename="Ruby version")]
//!     version: String,
//! }
//! let now = Metadata { version: "3.4.0".to_string() };
//! let diff = now.diff(&Metadata { version: "3.3.0".to_string() });
//!
//! assert_eq!("Ruby version (3.3.0 to 3.4.0)", diff.join(" "));
//! ```
//!

//! ## Handle structs missing display
//!
//! Not all structs implement the [`Display`](std::fmt::Display) trait, for example [`std::path::PathBuf`](std::path::PathBuf) requires that you call `display()` on it.
//!
//! The `#[derive(CacheDiff)]` macro will automatically handle the following conversions for you:
//!
//! - `std::path::PathBuf` (via [`std::path::Path::display`](std::path::Path::display))
//!
//! However, if you have a custom struct that does not implement [`Display`](std::fmt::Display), you can specify a function to call instead:
//!
//! ```rust
//! use cache_diff::CacheDiff;
//!
//! #[derive(CacheDiff)]
//! struct Metadata {
//!     #[cache_diff(display = my_function)]
//!     version: NoDisplay,
//! }
//!
//! #[derive(PartialEq)]
//! struct NoDisplay(String);
//! fn my_function(s: &NoDisplay) -> String {
//!     format!("custom {}", s.0)
//! }
//!
//! let now = Metadata { version: NoDisplay("3.4.0".to_string())};
//! let diff = now.diff(&Metadata { version: NoDisplay("3.3.0".to_string())});
//!
//! assert_eq!("version (custom 3.3.0 to custom 3.4.0)", diff.join(" "));
//! ```
//!

//! ## Customize one or more field differences
//!
//! You can provide a custom implementation for a diffing a subset of fields without having to roll your own implementation.
//!
//! ### Custom logic for one field example
//!
//! Here's an example where someone wants to bust the cache after N cache calls. Everything else other than `cache_usage_count` can be derived. If you want to keep the existing derived difference checks, but add on a custom one you can do it like this:
//!
//! ```rust
//! use cache_diff::CacheDiff;
//! const MAX: f32 = 200.0;
//!
//! #[derive(Debug, CacheDiff)]
//! #[cache_diff(custom = diff_cache_usage_count)]
//! pub(crate) struct Metadata {
//!     #[cache_diff(ignore = "custom")]
//!     cache_usage_count: f32,
//!
//!     binary_version: String,
//!     target_arch: String,
//!     os_distribution: String,
//!     os_version: String,
//! }
//!
//! fn diff_cache_usage_count(_old: &Metadata, now: &Metadata) -> Vec<String> {
//!     let Metadata {
//!         cache_usage_count,
//!         binary_version: _,
//!         target_arch: _,
//!         os_distribution: _,
//!         os_version: _,
//!     } = now;
//!
//!     if cache_usage_count > &MAX {
//!         vec![format!("Cache count ({}) exceeded limit {MAX}", cache_usage_count)]
//!     } else {
//!         Vec::new()
//!     }
//! }
//! ```
//!
//! In this example, four fields are derived automatically, saving us time, while one field is custom
//! using the `#[cache_diff(custom = diff_cache_usage_count)]` attribute on the struct. This tells
//! [CacheDiff] to call this function and pass in the old and current values. It expects a vector
//! with some strings if there is a difference and an empty vector if there are none.
//!
//! Don't forget to `#[cache_diff(ignore = "custom")]` any fields you're implementing yourself. You can also use this feature to
//! combine several fields into a single diff output, for example using the previous struct, if
//! you only wanted to have one output for a combined `os_distribution` and `os_version` in one output
//! like "OS (ubuntu-22 to ubuntu-24)". Alternatively, you can use <https://github.com/schneems/magic_migrate> to
//! re-arrange your struct to only have one field with a custom display.
pub use cache_diff_derive::CacheDiff;

// Code
pub trait CacheDiff {
    fn diff(&self, old: &Self) -> Vec<String>;
}

#[cfg(test)]
mod tests {
    // Test use
    use super::*;
    // Test code
    struct Metadata {
        ruby_version: String,
        architecture: String,
    }

    impl CacheDiff for Metadata {
        fn diff(&self, old: &Self) -> Vec<String> {
            let mut diff = Vec::new();

            if self.ruby_version != old.ruby_version {
                diff.push(format!("ruby version ({} to {})",
                old.ruby_version,
                self.ruby_version))
            }
            if self.architecture != old.architecture {
                diff.push(
                    format!("architecture ({} to {})",
                    old.architecture,
                    self.architecture)
                )
            }
            diff
        }
    }

    #[test]
    fn test_changed_metadata() {
        let old = Metadata {
            ruby_version: "3.3.1".to_string(),
            architecture: "amd64".to_string()
        };
        let new = Metadata {
            ruby_version: "3.4.2".to_string(),
            architecture: "arm64".to_string()
        };

        assert_eq!(
            vec![
                "ruby version (3.3.1 to 3.4.2)".to_string(),
                "architecture (amd64 to arm64)".to_string()
            ],
            new.diff(&old)
        );
    }

    #[test]
    fn test_unchanged_metadata() {
        let old = Metadata {
            ruby_version: "3.1.4".to_string(),
            architecture: "amd64".to_string()
        };

        let diff = old.diff(&old);
        assert!(
            diff.is_empty(),
            "Expected diff to be empty but is {:?}",
            diff
        );
    }
}
$ cat cache_diff_derive/src/lib.rs
// File: `cache_diff_derive/src/lib.rs`
mod parse_field;
mod parse_container;
use proc_macro::TokenStream;
use parse_container::ParseContainer;
use parse_field::ParseField;

// Code
pub(crate) const NAMESPACE: &str = "cache_diff";
pub(crate) const MACRO_NAME: &str = "CacheDiff";

#[proc_macro_derive(CacheDiff, attributes(cache_diff))]
pub fn cache_diff(item: TokenStream)
    -> TokenStream {
    create_cache_diff(item.into())
        .unwrap_or_else(syn::Error::into_compile_error)
        .into()
}

fn create_cache_diff(item: proc_macro2::TokenStream) -> syn::Result<proc_macro2::TokenStream> {
    let ParseContainer {
        ident,
        custom,
        fields,
    } = ParseContainer::from_derive_input(&syn::parse2(item)?)?;

    let custom_diff = if let Some(ref custom_fn) = custom {
        quote::quote! {
            let custom_diff = #custom_fn(old, self);
            for diff in &custom_diff {
                differences.push(diff.to_string())
            }
        }
    } else {
        quote::quote! {}
    };

    let mut comparisons = Vec::new();
    for field in fields.iter() {
        let ParseField {
            ident,
            name,
            ignore,
            display,
        } = field;

        if ignore.is_none() {
            comparisons.push(quote::quote! {
                if self.#ident != old.#ident {
                    differences.push(
                        format!("{name} ({old} to {new})",
                            name = #name,
                            old = #display(&old.#ident),
                            new = #display(&self.#ident)
                        )
                    );
                }
            });
        }
    }

    Ok(quote::quote! {
        impl cache_diff::CacheDiff for #ident {
            fn diff(&self, old: &Self) -> ::std::vec::Vec<String> {
                let mut differences = ::std::vec::Vec::new();
                #custom_diff
                #(#comparisons)*
                differences
            }
        }
    })
}
$ cat cache_diff_derive/src/parse_field.rs
// File: `cache_diff_derive/src/parse_field.rs`
use crate::MACRO_NAME;
use syn::spanned::Spanned;
use std::str::FromStr;
use strum::IntoEnumIterator;
use crate::NAMESPACE;

// Code
/// Field (i.e. `name: String`) of a container (struct) and its parsed attributes
/// i.e. `#[cache_diff(rename = "Ruby version")]`
#[derive(Debug)]
pub(crate) struct ParseField {
    /// The proc-macro identifier for a field i.e. `name: String` would be a programatic
    /// reference to `name` that can be used along with `quote!` to produce code.
    pub(crate) ident: syn::Ident,
    /// What the user will see when this field differs and invalidates the cache
    /// i.e. `age: usize` will be `"age"`.
    pub(crate) name: String,
    /// Whether or not the field is included in the derived diff comparison
    pub(crate) ignore: Option<String>,
    /// The function to use when rendering values on the field
    /// i.e. `age: 42` will be `"42"`
    pub(crate) display: syn::Path,
}

impl ParseField {
    pub(crate) fn from_field(field: &syn::Field) -> Result<Self, syn::Error> {
        let ident = field.ident.clone().ok_or_else(|| {
            syn::Error::new(
                field.span(),
                format!("{MACRO_NAME} can only be used on structs with named fields"),
            )
        })?;

        let attributes = ParseAttribute::from_attrs(&field.attrs)?;
        let name = attributes
            .iter()
            .filter_map(|attribute| match attribute {
                ParseAttribute::rename(name) => Some(name.to_owned()),
                _ => None,
            })
            .last()
            .unwrap_or_else(|| ident.to_string().replace("_", " "));
        let display = attributes
            .iter()
            .filter_map(|attribute| match attribute {
                ParseAttribute::display(display_fn) => Some(display_fn.to_owned()),
                _ => None,
            })
            .last()
            .unwrap_or_else(|| {
                if is_pathbuf(&field.ty) {
                    syn::parse_str("std::path::Path::display")
                        .expect("PathBuf::display parses as a syn::Path")
                } else {
                    syn::parse_str("std::convert::identity")
                        .expect("std::convert::identity parses as a syn::Path")
                }
            });

        let ignore = attributes
            .into_iter()
            .filter_map(|attribute| match attribute {
                ParseAttribute::ignore(reason) => Some(reason),
                _ => None,
            })
            .last();

        Ok(ParseField {
            ident,
            name,
            ignore,
            display,
        })
    }
}


/// A single attribute
#[derive(strum::EnumDiscriminants, Debug, PartialEq)]
#[strum_discriminants(derive(strum::EnumIter, strum::Display, strum::EnumString))]
#[strum_discriminants(name(KnownAttribute))]
enum ParseAttribute {
    #[allow(non_camel_case_types)]
    rename(String), // #[cache_diff(rename="...")]
    #[allow(non_camel_case_types)]
    display(syn::Path), // #[cache_diff(display=<function>)]
    #[allow(non_camel_case_types)]
    ignore(String), // #[cache_diff(ignore)]
}

impl syn::parse::Parse for KnownAttribute {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let identity: syn::Ident = input.parse()?;
        KnownAttribute::from_str(&identity.to_string()).map_err(|_| {
            syn::Error::new(
                identity.span(),
                format!(
                    "Unknown {NAMESPACE} attribute: `{identity}`. Must be one of {valid_keys}",
                    valid_keys = KnownAttribute::iter()
                        .map(|key| format!("`{key}`"))
                        .collect::<Vec<String>>()
                        .join(", ")
                ),
            )
        })
    }
}

impl syn::parse::Parse for ParseAttribute {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let key: KnownAttribute = input.parse()?;

        match key {
            KnownAttribute::rename => {
                input.parse::<syn::Token![=]>()?;
                Ok(ParseAttribute::rename(
                    input.parse::<syn::LitStr>()?.value(),
                ))
            }
            KnownAttribute::display => {
                input.parse::<syn::Token![=]>()?;
                Ok(ParseAttribute::display(input.parse()?))
            }
            KnownAttribute::ignore => {
                if input.peek(syn::Token![=]) {
                    input.parse::<syn::Token![=]>()?;
                    Ok(ParseAttribute::ignore(
                        input.parse::<syn::LitStr>()?.value(),
                    ))
                } else {
                    Ok(ParseAttribute::ignore("default".to_string()))
                }
            }
        }
    }
}

impl ParseAttribute {
    fn from_attrs(attrs: &[syn::Attribute]) -> Result<Vec<ParseAttribute>, syn::Error> {
        let mut attributes = Vec::new();
        for attr in attrs.iter().filter(|attr| attr.path().is_ident(NAMESPACE)) {
            for attribute in attr.parse_args_with(
                syn::punctuated::Punctuated::<ParseAttribute, syn::Token![,]>::parse_terminated,
            )? {
                attributes.push(attribute)
            }
        }

        Ok(attributes)
    }
}

fn is_pathbuf(ty: &syn::Type) -> bool {
    if let syn::Type::Path(type_path) = ty {
        if let Some(segment) = type_path.path.segments.last() {
            return segment.ident == "PathBuf" && segment.arguments == syn::PathArguments::None;
        }
    }
    false
}

#[cfg(test)]
mod tests {
    // Test use
    use super::*;
    // Test code
    #[test]
    fn test_parse_field_plain() {
        let field: syn::Field = syn::parse_quote! {
            ruby_version: String
        };

        let parsed = ParseField::from_field(&field).unwrap();
        assert_eq!("ruby version".to_string(), parsed.name);
    }

    #[test]
    fn test_requires_named_struct() {
        let field: syn::Field = syn::parse_quote! {()};

        let result = ParseField::from_field(&field);
        assert!(result.is_err(), "Expected an error, got {:?}", result);
        assert_eq!(
            format!("{}", result.err().unwrap()),
            r#"CacheDiff can only be used on structs with named fields"#
        );
    }

    #[test]
    fn test_known_attributes() {
        let parsed: KnownAttribute = syn::parse_str("rename").unwrap();
        assert_eq!(KnownAttribute::rename, parsed);

        let parsed: KnownAttribute = syn::parse_str("ignore").unwrap();
        assert_eq!(KnownAttribute::ignore, parsed);

        let parsed: KnownAttribute = syn::parse_str("display").unwrap();
        assert_eq!(KnownAttribute::display, parsed);

        let result: Result<KnownAttribute, syn::Error> = syn::parse_str("unknown");
        assert!(result.is_err(), "Expected an error, got {:?}", result);
        assert_eq!(
            format!("{}", result.err().unwrap()),
            r#"Unknown cache_diff attribute: `unknown`. Must be one of `rename`, `display`, `ignore`"#
        );
    }

    #[test]
    fn test_parse_attributes() {
        let parsed: ParseAttribute = syn::parse_str(r#"rename = "Ruby version""#).unwrap();
        assert_eq!(ParseAttribute::rename("Ruby version".to_string()), parsed);

        let parsed: ParseAttribute = syn::parse_str(r#"display= my_function"#).unwrap();
        assert!(matches!(parsed, ParseAttribute::display(_))); let parsed: ParseAttribute = syn::parse_str(r#"ignore = "i have my reasons""#).unwrap();
        assert!(matches!(parsed, ParseAttribute::ignore(_)));

        let parsed: ParseAttribute = syn::parse_str("ignore").unwrap();
        assert!(matches!(parsed, ParseAttribute::ignore(_)));
    }

    #[test]
    fn test_parse_rename_ignore_attribute() {
        let field: syn::Field = syn::parse_quote! {
            #[cache_diff(rename="Ruby version", ignore)]
            name: String
        };

        assert_eq!(
            vec![
                ParseAttribute::rename("Ruby version".to_string()),
                ParseAttribute::ignore("default".to_string()),
            ],
            ParseAttribute::from_attrs(&field.attrs).unwrap()
        );
    }
}
$ cat cache_diff_derive/src/parse_container.rs
// File: `cache_diff_derive/src/parse_container.rs`
use crate::parse_field::ParseField;
use crate::MACRO_NAME;
use std::str::FromStr;
use strum::IntoEnumIterator;
use crate::NAMESPACE;

// Code
/// Container (i.e. struct Metadata { ... }) and its parsed attributes
/// i.e. `#[cache_diff( ... )]`
#[derive(Debug)]
pub(crate) struct ParseContainer {
    /// The proc-macro identifier for a container i.e. `struct Metadata { }` would be a programatic
    /// reference to `Metadata` that can be used along with `quote!` to produce code.
    pub(crate) ident: syn::Ident,
    /// An optional path to a custom diff function
    /// Set via attribute on the container i.e. `#[cache_diff(custom = <function>)]`
    pub(crate) custom: Option<syn::Path>,
    /// Fields (i.e. `name: String`) and their associated attributes i.e. `#[cache_diff(...)]`
    pub(crate) fields: Vec<ParseField>,
}

impl ParseContainer {
    pub(crate) fn from_derive_input(input: &syn::DeriveInput) -> Result<Self, syn::Error> {
        let ident = input.ident.clone();
        let attributes = ParseAttribute::from_attrs(&input.attrs)?;
        let custom = attributes
            .into_iter()
            .map(|attribute| match attribute {
                ParseAttribute::custom(path) => path,
            })
            .last();
        let fields = match input.data {
            syn::Data::Struct(syn::DataStruct {
                fields: syn::Fields::Named(syn::FieldsNamed { ref named, .. }),
                ..
            }) => named,
            _ => {
                return Err(syn::Error::new(
                    ident.span(),
                    format!("{MACRO_NAME} can only be used on named structs"),
                ))
            }
        }
        .into_iter()
        .map(ParseField::from_field)
        .collect::<Result<Vec<ParseField>, syn::Error>>()?;

        if let Some(field) = fields
            .iter()
            .find(|field| matches!(field.ignore.as_deref(), Some("custom")))
        {
            if custom.is_none() {
                return Err(syn::Error::new(ident.span(),
                            format!(
                                "field `{field}` on {container} marked ignored as custom, but no `#[{NAMESPACE}(custom = <function>)]` found on `{container}`",
                                field = field.ident,
                                container = &ident,
                            )));
            }
        }

        if fields.iter().any(|f| f.ignore.is_none()) {
            Ok(ParseContainer {
                ident,
                fields,
                custom,
            })
        } else {
            Err(syn::Error::new(ident.span(), format!("No fields to compare for {MACRO_NAME}, ensure struct has at least one named field that isn't `{NAMESPACE}(ignore)`")))
        }
    }
}

/// A single attribute
#[derive(strum::EnumDiscriminants, Debug, PartialEq)]
#[strum_discriminants(derive(strum::EnumIter, strum::Display, strum::EnumString))]
#[strum_discriminants(name(KnownAttribute))]
enum ParseAttribute {
    #[allow(non_camel_case_types)]
    custom(syn::Path), // #[cache_diff(custom=<function>)]
}

impl syn::parse::Parse for KnownAttribute {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let identity: syn::Ident = input.parse()?;
        KnownAttribute::from_str(&identity.to_string()).map_err(|_| {
            syn::Error::new(
                identity.span(),
                format!(
                    "Unknown {NAMESPACE} attribute: `{identity}`. Must be one of {valid_keys}",
                    valid_keys = KnownAttribute::iter()
                        .map(|key| format!("`{key}`"))
                        .collect::<Vec<String>>()
                        .join(", ")
                ),
            )
        })
    }
}

impl ParseAttribute {
    fn from_attrs(attrs: &[syn::Attribute]) -> Result<Vec<ParseAttribute>, syn::Error> {
        let mut attributes = Vec::new();
        for attr in attrs.iter().filter(|attr| attr.path().is_ident(NAMESPACE)) {
            for attribute in attr.parse_args_with(
                syn::punctuated::Punctuated::<ParseAttribute, syn::Token![,]>::parse_terminated,
            )? {
                attributes.push(attribute)
            }
        }

        Ok(attributes)
    }
}

impl syn::parse::Parse for ParseAttribute {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let key: KnownAttribute = input.parse()?;
        input.parse::<syn::Token![=]>()?;
        match key {
            KnownAttribute::custom => Ok(ParseAttribute::custom(input.parse()?)),
        }
    }
}

#[cfg(test)]
mod tests {
    // Test use
    use super::*;
    // Test code
    #[test]
    fn test_parses() {
        let container = ParseContainer::from_derive_input(&syn::parse_quote! {
            struct Metadata {
                version: String
            }
        })
        .unwrap();
        assert_eq!(1, container.fields.len());

        let container = ParseContainer::from_derive_input(&syn::parse_quote! {
            struct Metadata {
                version: String,
                checksum: String
            }
        })
        .unwrap();
        assert_eq!(2, container.fields.len());
    }

    #[test]
    fn test_known_attributes() {
        let attribute: KnownAttribute = syn::parse_str("custom").unwrap();
        assert_eq!(KnownAttribute::custom, attribute);
    }

    #[test]
    fn test_parse_attribute() {
        let attribute: ParseAttribute = syn::parse_str("custom = my_function").unwrap();
        assert!(matches!(attribute, ParseAttribute::custom(_)));

        let result: Result<ParseAttribute, syn::Error> = syn::parse_str("unknown");
        assert!(result.is_err(), "Expected an error, got {:?}", result);
        assert_eq!(
            r"Unknown cache_diff attribute: `unknown`. Must be one of `custom`",
            format!("{}", result.err().unwrap()),
        );
    }

    #[test]
    fn test_custom_parse_attribute() {
        let input: syn::DeriveInput = syn::parse_quote! {
            #[cache_diff(custom = my_function)]
            struct Metadata {
                name: String
            }
        };

        assert!(matches!(
            ParseAttribute::from_attrs(&input.attrs)
                .unwrap()
                .first(),
            Some(ParseAttribute::custom(_))
        ));
    }

    #[test]
    fn test_no_fields() {
        let result = ParseContainer::from_derive_input(&syn::parse_quote! {
            struct Metadata { }
        });
        assert!(result.is_err(), "Expected an error, got {:?}", result);
        assert_eq!(
            format!("{}", result.err().unwrap()),
            r#"No fields to compare for CacheDiff, ensure struct has at least one named field that isn't `cache_diff(ignore)`"#
        );
    }

    #[test]
    fn test_all_ignored() {
        let result = ParseContainer::from_derive_input(&syn::parse_quote! {
            struct Metadata {
                #[cache_diff(ignore)]
                version: String
            }
        });
        assert!(result.is_err(), "Expected an error, got {:?}", result);
        assert_eq!(
            format!("{}", result.err().unwrap()),
            r#"No fields to compare for CacheDiff, ensure struct has at least one named field that isn't `cache_diff(ignore)`"#
        );
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->
</details>

