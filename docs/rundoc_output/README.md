<!-- STOP
  This file was generated by a rundoc script, do not modify it.

  Instead modify the rundoc script and re-run it.

  Command: /Users/rschneeman/.gem/ruby/3.4.2/bin/rundoc docs/RUNDOC.md
STOP -->
# Deriving School: Build a Rust proc-macro in one sitting

Welcome to Deriving School. I'll be your Deriving instructor for the day. This tutorial will walk you through creating a Rust trait that can be manually implemented, then writing a Derive proc-macro to implement the trait, and then adding macro attributes that configure the behavior of that code generation. There are many different ways to write a Derive macro; this tutorial heavily emphasizes testing, integration testing, high-quality errors, and enforcing valid states through types and patterns that can be extended for your needs. If that sounds exciting, buckle up, and let's get Deriving!


By the end of this tutorial, we'll have a working `CacheDiff` macro with attributes that function like this:

```rust
#[derive(CacheDiff)]
#[cache_diff(custom = diff_cache_usage_count)]
pub(crate) struct Metadata {
    #[cache_diff(ignore = "custom")]
    cache_usage_count: f32,
    #[cache_diff(rename = "Ruby version")]
    binary_version: String,
    target_arch: String,
    os_distribution: String,
    os_version: String,
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

What makes me qualified to be a Deriving instructor? I write Rust code for my day job at Heroku, where I maintain the [Ruby Cloud Native Buildpack](https://github.com/heroku/buildpacks-ruby). If you're unfamiliar with [Cloud Native Buildpacks](https://buildpacks.io/), it's a CNCF project that competes with Dockerfile to generate [OCI images](https://opencontainers.org/). The best introduction to Cloud Native Buildpacks is through a [language-specific tutorial, such as Build a Ruby on Rails application image in 5 minutes, with no Dockerfile required](https://github.com/heroku/buildpacks/blob/main/docs/ruby/README.md). In addition to my day job, I teach elementary school kids how to program. I'm the author of How to Open Source (book) and a Ruby Core Contributor. I'm only a few years into writing professional Rust, but I've over a decade of experience writing DSLs and working with reflection. Even though I'll be your instructor today, there's still a lot for me to learn; if you have a concrete suggestion on how to improve this tutorial, please contact [Mastodon](https://ruby.social/@schneems).

Before we get started, though, I will need to check your learner's permit. I assume you're comfortable with Rust syntax, have worked through "The Rust book," and can easily manage [rustlings exercises](https://github.com/rust-lang/rustlings). If that's not the case, I suggest you skim the article today, spend more time on the basics, and return later. If you're ready to start, put on some [good tunes](https://www.youtube.com/watch?v=hEUs9rwNFcs), and let's begin Deriving!

## What is a CacheDiff?

The [CacheDiff trait](https://crates.io/crates/cache_diff) comes from a real-world desire for a standard interface for communicating when a cache must be invalidated and why. In [libcnb.rs](https://crates.io/crates/libcnb), the cache state is represented by a serialized struct, often called metadata. For example, if a target application specifies a version in its metadata, we should clear the old contents when the value changes and communicate why the cache was cleared. For example:

> "Ruby version changed (3.1.3 to 3.4.2)"

As the tutorial progresses, you'll see details of how this trait is used and why. You've already got enough information to understand what we're Deriving toward.

## Table of Contents

- [01 - Create the project](#chapter_01)
- [02 - Create an empty Proc Macro](#chapter_02)
- [03 - Create a ParseField to Derive with](#chapter_03)
- [04 - Create a ParseContainer to Derive with](#chapter_04)
- [05 - Implement the basic Derive macro](#chapter_05)
- [06 - Understanding attributes for Derive customization](#chapter_06)
- [07 - Add attributes to ParseField](#chapter_07)
- [08 - Add attributes to ParseContainer](#chapter_08)
- [09 - Implement the All-Wheel Derive Macro (customizable with attributes)](#chapter_09)
<span id="chapter_01" />

## 01: Create the project

We will begin by creating two projects: one to hold our trait definition and one to hold our "derive" proc macro.

```term
$ mkdir cache_diff
$ cd cache_diff
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Initialize two projects:

```term
$ cargo init cache_diff --lib
$ cargo init cache_diff_derive --lib
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Tell Rust that these two projects live under one unified workspace by creating a `Cargo.toml` in the root (one directory above the projects you just made).

In file `Cargo.toml` write:

```toml
[workspace]
members = [
    "cache_diff",
    "cache_diff_derive"
]
resolver = "2"
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

This workspace will allow us to run all tests via `cargo test` from the top-level directory. Ignore your build files so they don't appear in the debug output later.

In file `.gitignore` write:

```
target/
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->


The project now looks like this:

```term
$ exa --tree --git-ignore .
.
├── cache_diff
│  ├── Cargo.toml
│  └── src
│     └── lib.rs
├── cache_diff_derive
│  ├── Cargo.toml
│  └── src
│     └── lib.rs
└── Cargo.toml
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

We need two crates because a proc-macro must live in a stand-alone crate. This split allows Rust to compile and run that code before the rest of the code in a project is compiled. A limitation is that it can only export macros, so we need somewhere else for other public things (like traits) to live.

## Define the CacheDiff trait manually

Once the project is set up, we'll start by defining a public trait:

```rust
// File: `cache_diff/src/lib.rs`

// Code
pub trait CacheDiff {
    fn diff(&self, old: &Self) -> Vec<String>;
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

This trait is short. It's designed to communicate that a struct is intended to be used as a cache key. You'll see how it's used in some tests below.

Fundamentally, macros are a form of metaprogramming: code that writes code. Before jumping into any kind of automation, you'll want to understand how to do the task manually first. I try to iterate as much as possible manually before solidifying things in macros.

## Manually implement the trait

> [Skip](#chapter_02) the rest of this section if: You already understand how the trait interface could be used and could write your tests for it.

Here's a test showing how a developer might manually implement this trait. First, we will add a "stringly" typed `Metadata` struct and implement the `CacheDiff` trait to simulate a world where we're storing a version of an architecture-dependent binary that we're installing:

```rust
// File: `cache_diff/src/lib.rs`

// Code
// ...

#[cfg(test)]
mod tests {
    // Test use
    use super::*;
    // Test code
    struct Metadata {
        ruby_version: String,
        architecture: String,
    }

    impl CacheDiff for Metadata {
        fn diff(&self, old: &Self) -> Vec<String> {
            let mut diff = Vec::new();

            if self.ruby_version != old.ruby_version {
                diff.push(format!("ruby version ({} to {})",
                old.ruby_version,
                self.ruby_version))
            }
            if self.architecture != old.architecture {
                diff.push(
                    format!("architecture ({} to {})",
                    old.architecture,
                    self.architecture)
                )
            }
            diff
        }
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

With that definition out of the way, we can assert that the interface behaves as expected. Add this test case:

```rust
// File: `cache_diff/src/lib.rs`

// Code
// ...

#[cfg(test)]
mod tests {
    // Test use
    // ...

    // Test code
    // ...
    #[test]
    fn test_changed_metadata() {
        let old = Metadata {
            ruby_version: "3.3.1".to_string(),
            architecture: "amd64".to_string()
        };
        let new = Metadata {
            ruby_version: "3.4.2".to_string(),
            architecture: "arm64".to_string()
        };

        assert_eq!(
            vec![
                "ruby version (3.3.1 to 3.4.2)".to_string(),
                "architecture (amd64 to arm64)".to_string()
            ],
            new.diff(&old)
        );
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

It's usually a good idea to assert both positive and negative behavior. Add this test case:

```rust
// File: `cache_diff/src/lib.rs`

// Code
// ...

#[cfg(test)]
mod tests {
    // Test use
    // ...

    // Test code
    // ...
    #[test]
    fn test_unchanged_metadata() {
        let old = Metadata {
            ruby_version: "3.1.4".to_string(),
            architecture: "amd64".to_string()
        };

        let diff = old.diff(&old);
        assert!(
            diff.is_empty(),
            "Expected diff to be empty but is {:?}",
            diff
        );
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Your file should now look like this:

```rust
// File: `cache_diff/src/lib.rs`

// Code
pub trait CacheDiff {
    fn diff(&self, old: &Self) -> Vec<String>;
}

#[cfg(test)]
mod tests {
    // Test use
    use super::*;
    // Test code
    struct Metadata {
        ruby_version: String,
        architecture: String,
    }

    impl CacheDiff for Metadata {
        fn diff(&self, old: &Self) -> Vec<String> {
            let mut diff = Vec::new();

            if self.ruby_version != old.ruby_version {
                diff.push(format!("ruby version ({} to {})",
                old.ruby_version,
                self.ruby_version))
            }
            if self.architecture != old.architecture {
                diff.push(
                    format!("architecture ({} to {})",
                    old.architecture,
                    self.architecture)
                )
            }
            diff
        }
    }

    #[test]
    fn test_changed_metadata() {
        let old = Metadata {
            ruby_version: "3.3.1".to_string(),
            architecture: "amd64".to_string()
        };
        let new = Metadata {
            ruby_version: "3.4.2".to_string(),
            architecture: "arm64".to_string()
        };

        assert_eq!(
            vec![
                "ruby version (3.3.1 to 3.4.2)".to_string(),
                "architecture (amd64 to arm64)".to_string()
            ],
            new.diff(&old)
        );
    }

    #[test]
    fn test_unchanged_metadata() {
        let old = Metadata {
            ruby_version: "3.1.4".to_string(),
            architecture: "amd64".to_string()
        };

        let diff = old.diff(&old);
        assert!(
            diff.is_empty(),
            "Expected diff to be empty but is {:?}",
            diff
        );
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

And when you run tests, it should look a little like this:

```
$ cargo test
   Compiling cache_diff_derive v0.1.0 (/private/var/folders/yr/yytf3z3n3q336f1tj2b2j0gw0000gn/T/d20250318-97315-gjz2i5/cache_diff/cache_diff_derive)
   Compiling cache_diff v0.1.0 (/private/var/folders/yr/yytf3z3n3q336f1tj2b2j0gw0000gn/T/d20250318-97315-gjz2i5/cache_diff/cache_diff)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.17s
     Running unittests src/lib.rs (target/debug/deps/cache_diff-2716017b25caff21)

running 2 tests
test tests::test_unchanged_metadata ... ok
test tests::test_changed_metadata ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/lib.rs (target/debug/deps/cache_diff_derive-5abb2abc0d81814e)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests cache_diff

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests cache_diff_derive

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

## Why Derive when we can walk?

The `CacheDiff` trait isn't too complicated to implement manually, but the code is repetitive. There's also room to mess up the output, like inverting the version number position or comparing one field and displaying values for a different one.

A derive macro would reduce repetition and eliminate silly logic errors while providing sensible defaults.
<span id="chapter_02" />

## 02: Create an empty Proc Macro

To write a proc macro, we will need some crates. Add them now:

At the end of `cache_diff_derive/Cargo.toml` add:

```toml
# Turn Rust code into Tokens
quote = "1.0.37"
# Parse tokens into Rust code
syn = { version = "2.0.83", features = ["extra-traits"] }
proc-macro2 = "1.0.89"
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

I'll talk about what these do as we use them. We also need to tell Rust that this library is a proc macro.

At the end of `cache_diff_derive/Cargo.toml` add:

```toml
[lib]
proc-macro = true
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Now, we need to add an entry point and define some constants we'll use in a bit. Add this code:

```rust




// File: `cache_diff_derive/src/lib.rs`
use proc_macro::TokenStream;
// Code
pub(crate) const NAMESPACE: &str = "cache_diff";
pub(crate) const MACRO_NAME: &str = "CacheDiff";

#[proc_macro_derive(CacheDiff, attributes(cache_diff))]
pub fn cache_diff(item: TokenStream)
    -> TokenStream {
    create_cache_diff(item.into())
        .unwrap_or_else(syn::Error::into_compile_error)
        .into()
}

fn create_cache_diff(item: proc_macro2::TokenStream)
    -> syn::Result<proc_macro2::TokenStream> {
    Ok(quote::quote! { })
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

What does this code do? We just created a function `cache_diff` that is annotated with a proc macro (how meta):

```rust
#[proc_macro_derive(CacheDiff, attributes(cache_diff))]
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

This line says that we provide a derive macro named `CacheDiff` and that it should accept some attributes that start with `#[cache_diff()]`. Initially, I thought it would only show me the attributes I was interested in (i.e., prefixed with `cache_diff`), but it doesn't; the proc macro sees all attributes in the source code. If the struct has different attributes from different crates (such as `serde`) then our macro can see them. We must manually filter attributes later to see only the ones we care about.

The next bit defines a function `cache_diff` that will receive a `proc_macro::TokenStream` containing information about the code we're annotating:

```rust
pub fn cache_diff(item: TokenStream)
    -> TokenStream {
    create_cache_diff(item.into())
        .unwrap_or_else(syn::Error::into_compile_error)
        .into()
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

It calls a function `create_cache_diff`, which returns a `syn::Result<proc_macro2::TokenStream>>`. That's either a parse error or a stream of tokens. In the event of a problem, we want to map it into a pretty compile error with source code highlighting where the issue happened with underlines and arrows and all that nice output that Rust users know and love. Inside the `create_cache_diff` function, I added a call to the `quote::quote!` macro:

```rust
fn create_cache_diff(item: proc_macro2::TokenStream)
    -> syn::Result<proc_macro2::TokenStream> {
    Ok(quote::quote! { })
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

This macro converts text into rust code. We can also pass in variables, but we just want the code to compile for now. Verify your code builds:

```term
$ cargo build
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Congrats! You just wrote your first proc macro! We'll need to expose it through our non-derive crate, which also carries the trait definition. First, declare a dependency on our derive crate:

At the end of `cache_diff/Cargo.toml` add:

```toml
cache_diff_derive = { version = "0.1.0" , optional = true, path = "../cache_diff_derive" }

[features]
derive = ["dep:cache_diff_derive"]
default = ["derive"]
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

This TOML declares a dependency on our derive macro. It's optional because proc macros are "heavier" than a regular dependency, and they must compile and execute before your code can compile and execute. Someone might want to pull in only the trait to use it as an interface or to manually implement it for a struct (meaning they don't need our automation). Many popular libraries, such as [the clap CLI builder](https://github.com/clap-rs/clap/blob/fdbbf66e77c83688f52b7a206d64102582af40d3/Cargo.toml#L161) gate their proc macros behind a feature. While many users will use the `derive` features, those who don't won't have to pay the (relatively small in this case, but very real) cost. I assume people want to use it by default, so it's enabled automatically. Users can deactivate it by specifying `cache_diff = { default-features = false }` in the `Cargo.toml`.

Now we re-export that macro right next to our trait when the "derive" feature is enabled:

```rust
// File: `cache_diff/src/lib.rs`
#[cfg(feature = "derive")]
pub use cache_diff_derive::CacheDiff;
// Code
// ...
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

The file should look like this:

```rust
// File: `cache_diff/src/lib.rs`
#[cfg(feature = "derive")]
pub use cache_diff_derive::CacheDiff;
// Code
pub trait CacheDiff {
    fn diff(&self, old: &Self) -> Vec<String>;
}

#[cfg(test)]
mod tests {
    // Test use
    use super::*;
    // Test code
    struct Metadata {
        ruby_version: String,
        architecture: String,
    }

    impl CacheDiff for Metadata {
        fn diff(&self, old: &Self) -> Vec<String> {
            let mut diff = Vec::new();

            if self.ruby_version != old.ruby_version {
                diff.push(format!("ruby version ({} to {})",
                old.ruby_version,
                self.ruby_version))
            }
            if self.architecture != old.architecture {
                diff.push(
                    format!("architecture ({} to {})",
                    old.architecture,
                    self.architecture)
                )
            }
            diff
        }
    }

    #[test]
    fn test_changed_metadata() {
        let old = Metadata {
            ruby_version: "3.3.1".to_string(),
            architecture: "amd64".to_string()
        };
        let new = Metadata {
            ruby_version: "3.4.2".to_string(),
            architecture: "arm64".to_string()
        };

        assert_eq!(
            vec![
                "ruby version (3.3.1 to 3.4.2)".to_string(),
                "architecture (amd64 to arm64)".to_string()
            ],
            new.diff(&old)
        );
    }

    #[test]
    fn test_unchanged_metadata() {
        let old = Metadata {
            ruby_version: "3.1.4".to_string(),
            architecture: "amd64".to_string()
        };

        let diff = old.diff(&old);
        assert!(
            diff.is_empty(),
            "Expected diff to be empty but is {:?}",
            diff
        );
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

With this skeleton in place, we will define structs to hold data. This code will allow us to implement the base behavior and gradually add custom attributes.
<span id="chapter_03" />

## 03: Create a ParseField to Derive with

Many aspiring drivers learn in an empty parking lot. We'll start Deriving for real with an empty field.

A field in our context refers to a name and type within a struct. For example:

```rust
struct Metadata {
    version: String
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

This struct has one field named `version` with a value of `String` type. We need a way to model this concept in our code and add it later. Create this file and add this code now:

```rust
// File: `cache_diff_derive/src/parse_field.rs`

// Code
/// Field (i.e. `name: String`) of a container (struct) and its parsed attributes
/// i.e. `#[cache_diff(rename = "Ruby version")]`
#[derive(Debug)]
pub(crate) struct ParseField {
    /// The proc-macro identifier for a field i.e. `name: String` would be a programmatic
    /// reference to `name` that can be used along with `quote!` to produce code.
    pub(crate) ident: syn::Ident,
    /// What the user will see when this field differs and invalidates the cache
    /// i.e. `age: usize` will be `"age"`.
    pub(crate) name: String,
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

The `ident` field on `ParseField` holds a `syn::Ident`, which is shorthand for an "identifier" of Rust code. We'll use this when we want to compare one field value to another, so `old.version != new.version` would become `old.#ident != new.#ident`. The [syn crate](https://crates.io/crates/syn) ships with many [pre-defined data structures that represent various Rust code](https://docs.rs/syn/2.0.99/syn/#structs) that we can easily parse a `TokenStream` into.

Then, we store the `name` of the field we want to show when a difference is detected. We want it to look nice, so instead of showing a string like `"ruby_version"` we'll convert it to `"ruby version"` (with a space instead of an underscore). This conversion isn't strictly required, but it makes the output prettier, and decoupling the ident from its display representation will be used later.

We must `mod` it from the `lib.rs` to use this code. Do that now:

```rust
// File: `cache_diff_derive/src/lib.rs`
mod parse_field;
// Use ...

// Code
// ...
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Now that we've got somewhere to put data, we need some logic to build it. Add this code:

```rust



// File: `cache_diff_derive/src/parse_field.rs`
use crate::MACRO_NAME;
use syn::spanned::Spanned;
// Code
// ...
impl ParseField {
    pub(crate) fn from_field(field: &syn::Field) -> Result<Self, syn::Error> {
        let ident = field.ident.clone().ok_or_else(|| {
            syn::Error::new(
                field.span(),
                format!("{MACRO_NAME} can only be used on structs with named fields"),
            )
        })?;

        let name = ident.to_string().replace("_", " ");

        Ok(ParseField {
            ident,
            name,
        })
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

The function we added takes in a `syn::Field`, a parsing abstraction over a struct's fields, and returns itself of a `syn::Error`:

```rust
    pub(crate) fn from_field(field: &syn::Field) -> Result<Self, syn::Error> {
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

This next bit of code pulls out the identity of the field if there is one or returns `syn::Error`:

```rust
        let ident = field.ident.clone().ok_or_else(|| {
            syn::Error::new(
                field.span(),
                format!("{MACRO_NAME} can only be used on structs with named fields"),
            )
        })?;
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

As the error message suggests, this might be `None` if someone tried to use the derive macro on something with a field without an ident like a tuple struct (i.e. `struct Metadata(String)`). The first argument of the error takes in a `syn::Span`. A span is a common parsing abstraction not unique to syn or Rust, it represents a sequence of characters in our input. The `syn` crate uses this information to add underlines and arrows that Rust developers have come to expect. To use the span from the field input, we have to import the `syn::spanned::Spanned` trait.

You can also panic in a macro, but part of being a great Deriver is about going above and beyond to signal intent and help others.

From there, we gather the string representation of our identity and replace underscores with spaces:

```rust
        let name = ident.to_string().replace("_", " ");
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

That's how the code works, but don't take my word for it. Let's see the code in action. Add a test:



This test code uses the `syn::parse_quote!` macro to generate a `syn::Field` that we can pass to the associated function we just defined. We have to annotate the type in the test, or `syn` won't know what data structure we're trying to represent in our code. From there, it asserts that our naming logic works as expected.

Happy paths are nice, but what about that error from earlier? Add a test now:



This is our code so far:

```rust
// File: `cache_diff_derive/src/parse_field.rs`
use crate::MACRO_NAME;
use syn::spanned::Spanned;
// Code
/// Field (i.e. `name: String`) of a container (struct) and its parsed attributes
/// i.e. `#[cache_diff(rename = "Ruby version")]`
#[derive(Debug)]
pub(crate) struct ParseField {
    /// The proc-macro identifier for a field i.e. `name: String` would be a programmatic
    /// reference to `name` that can be used along with `quote!` to produce code.
    pub(crate) ident: syn::Ident,
    /// What the user will see when this field differs and invalidates the cache
    /// i.e. `age: usize` will be `"age"`.
    pub(crate) name: String,
}

impl ParseField {
    pub(crate) fn from_field(field: &syn::Field) -> Result<Self, syn::Error> {
        let ident = field.ident.clone().ok_or_else(|| {
            syn::Error::new(
                field.span(),
                format!("{MACRO_NAME} can only be used on structs with named fields"),
            )
        })?;

        let name = ident.to_string().replace("_", " ");

        Ok(ParseField {
            ident,
            name,
        })
    }
}

#[cfg(test)]
mod tests {
    // Test use
    use super::*;
    // Test code
    #[test]
    fn test_parse_field_plain() {
        let field: syn::Field = syn::parse_quote! {
            ruby_version: String
        };

        let parsed = ParseField::from_field(&field).unwrap();
        assert_eq!("ruby version".to_string(), parsed.name);
    }

    #[test]
    fn test_requires_named_struct() {
        let field: syn::Field = syn::parse_quote! {()};

        let result = ParseField::from_field(&field);
        assert!(result.is_err(), "Expected an error, got {:?}", result);
        assert_eq!(
            format!("{}", result.err().unwrap()),
            r#"CacheDiff can only be used on structs with named fields"#
        );
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Run tests to make sure everything works as expected:

```
$ cargo test
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Now that we have a field for Deriving let's model our container.
<span id="chapter_04" />

## 04: Create a ParseContainer to Derive with

A container, in our context, is a struct. For example:

```rust
struct Metadata {
    version: String
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

The container in this code is `Metadata` as it contains our fields. In proc-macro land, a container can also be an enum. We want a way to model a container that holds zero or more named fields. Create this file and add this code:

```rust


// File: `cache_diff_derive/src/parse_container.rs`
use crate::parse_field::ParseField;
// Code
/// Container (i.e. struct Metadata { ... }) and its parsed attributes
/// i.e. `#[cache_diff( ... )]`
#[derive(Debug)]
pub(crate) struct ParseContainer {
    /// The proc-macro identifier for a container i.e. `struct Metadata { }` would be a programmatic
    /// reference to `Metadata` that can be used along with `quote!` to produce code.
    pub(crate) ident: syn::Ident,
    /// Info about generics, lifetimes and where clauses i.e. `struct Metadata<T> { name: T }`
    pub(crate) generics: syn::Generics,
    /// Fields (i.e. `name: String`) and their associated attributes i.e. `#[cache_diff(...)]`
    pub(crate) fields: Vec<ParseField>,
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Like before, we're holding a reference to `syn::Ident`, which holds the identity of the struct (i.e., `Metadata`). Then, we're also capturing the `syn::Generics`, which holds information needed to support things like structs with generics or where clauses. Then, instead of storing a `syn` data type for fields, we're holding a `Vec` of the `ParseField` struct we defined previously.

Don't forget to let our project know about the new file by adding a `mod` declaration. Add it now:

```rust
// File: `cache_diff_derive/src/lib.rs`
// Mod ...
mod parse_container;
// Use ...

// Code
// ...
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Now that we've got a place to hold the data let's build it from the input AST. Add this code:

```rust
// File: `cache_diff_derive/src/parse_container.rs`
// Use ...
use crate::MACRO_NAME;
// Code
// ...
impl ParseContainer {
    pub(crate) fn from_derive_input(input: &syn::DeriveInput) -> Result<Self, syn::Error> {
        let ident = input.ident.clone();
        let generics = input.generics.clone();
        let fields = match input.data {
            syn::Data::Struct(syn::DataStruct {
                fields: syn::Fields::Named(syn::FieldsNamed { ref named, .. }),
                ..
            }) => named,
            _ => {
                return Err(syn::Error::new(
                    ident.span(),
                    format!("{MACRO_NAME} can only be used on named structs"),
                ))
            }
        }
        .into_iter()
        .map(ParseField::from_field)
        .collect::<Result<Vec<ParseField>, syn::Error>>()?;

        Ok(ParseContainer { ident, generics, fields })
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

What does this code do? The function takes in a `syn::DeriveInput` and returns itself or a `syn::Error` (just like `ParseField` did!):

```rust
    pub(crate) fn from_derive_input(input: &syn::DeriveInput) -> Result<Self, syn::Error> {
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

While `ParseField` took in a `syn::Field`, there's no pre-defined "container" type from syn; instead, `syn::DeriveInput` is anything that could be passed to a derive macro. You can mentally substitute the word "container" whenever you see `DeriveInput` because derive macros can only be applied to containers. If you need a mental image, think of a big rig (truck) driving to your town containing lots of goodies. Containers are derivable.

> Derive input == container == (struct or enum or union)

All containers for our macro are named, so we can pull an identity directly (without needing to raise an error as we did with fields):

```rust
        let ident = input.ident.clone();
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

This next bit is tricky. We will break it down:

```rust
        let fields = match input.data {
            syn::Data::Struct(syn::DataStruct {
                fields: syn::Fields::Named(syn::FieldsNamed { ref named, .. }),
                ..
            }) => named,
            _ => {
                return Err(syn::Error::new(
                    ident.span(),
                    format!("{MACRO_NAME} can only be used on named structs"),
                ))
            }
        }
        .into_iter()
        .map(ParseField::from_field)
        .collect::<Result<Vec<ParseField>, syn::Error>>()?;
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Because a `DeriveInput` (A.K.A. "container") can take different shapes (struct, enum, or union), we can use a match statement to extract the information we need from named fields.

The return value from `syn::Data` here is a `&syn::Punctuated<syn::Field, syn::Token::Comma>`, which is a fancy way of saying that it's a `syn::Field` that is separated by commas. We can iterate over that type to yield `&syn::Field`, which is what our `ParseField::from_field` function takes in:

```rust
        .into_iter()
        .map(ParseField::from_field)
        .collect::<Result<Vec<ParseField>, syn::Error>>()?;
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

If that parsing is successful, then we'll have our data! But not so fast **speed racer**. We can't pass GO until we write some tests. Add this test code now:

```rust

// File: `cache_diff_derive/src/parse_container.rs`
// Use ...

// Code
// ...

#[cfg(test)]
mod tests {
    // Test use
    use super::*;
    // Test code
    #[test]
    fn test_parses() {
        let container = ParseContainer::from_derive_input(&syn::parse_quote! {
            struct Metadata {
                version: String
            }
        })
        .unwrap();
        assert_eq!(1, container.fields.len());

        let container = ParseContainer::from_derive_input(&syn::parse_quote! {
            struct Metadata {
                version: String,
                checksum: String
            }
        })
        .unwrap();
        assert_eq!(2, container.fields.len());
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Verify it works:

```
$ cargo test
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

At this point, we've got a custom representation for our fields and the container (that holds the fields). We'll use this to generate a simple version of our trait before extending our simple data structures to hold attribute information.
<span id="chapter_05"/>

## 05: Implement the basic Derive macro

We will now use these container and field structs that we created to implement our base logic. Import the structs we created:

```rust


// File: `cache_diff_derive/src/lib.rs`
// Mod ...

// Use ...
use parse_container::ParseContainer;
use parse_field::ParseField;
// Code
// ...
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Replace our prior cache logic:

```rust
// File: `cache_diff_derive/src/lib.rs`
// Mod ...

// Use ...

// Code
// ...
fn create_cache_diff(item: proc_macro2::TokenStream)
    -> syn::Result<proc_macro2::TokenStream> {
    Ok(quote::quote! { })
}


```

With with these new contents:


```rust
// File: `cache_diff_derive/src/lib.rs`
// Mod ...

// Use ...

// Code
// ...
fn create_cache_diff(item: proc_macro2::TokenStream)
    -> syn::Result<proc_macro2::TokenStream> {
    let derive_input: syn::DeriveInput = syn::parse2(item)?;
    let container = ParseContainer::from_derive_input(&derive_input)?;
    let ident = &container.ident;
    let generics = &container.generics;

    let mut comparisons = Vec::new();
    for field in container.fields.iter() {
        let ParseField {
            ident,
            name,
            ..
        } = field;

        comparisons.push(quote::quote! {
            if self.#ident != old.#ident {
                differences.push(
                    format!("{name} ({old} to {new})",
                        name = #name,
                        old = &old.#ident,
                        new = &self.#ident,
                    )
                );
            }
        });
    }
    let (impl_generics, type_generics, where_clause) = generics.split_for_impl();
    Ok(quote::quote! {
        impl #impl_generics ::cache_diff::CacheDiff for #ident #type_generics #where_clause {
            fn diff(&self, old: &Self) -> ::std::vec::Vec<String> {
                let mut differences = ::std::vec::Vec::new();
                #(#comparisons)*
                differences
            }
        }
    })
}


```

That's a lot of code, let's break it down. The first thing we do is generate a `syn::DeriveInput` from the token stream:

```rust
    let derive_input: syn::DeriveInput = syn::parse2(item)?;
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

The function `syn::parse2` is especially designed to turn a `proc_macro2::TokenStream` into a syn struct such as `syn::DeriveInput`. Next we build our container structure from this parsed input:

```rust
    let container = ParseContainer::from_derive_input(&derive_input)?;
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

We will need the identity of the container (i.e. `Metadata`) for code generation later with the `quote::quote!` macro:

```rust
    let ident = &container.ident;
    // ...
    Ok(quote::quote! {
        impl #impl_generics ::cache_diff::CacheDiff for #ident #type_generics #where_clause {
            fn diff(&self, old: &Self) -> ::std::vec::Vec<String> {
                let mut differences = ::std::vec::Vec::new();
                #(#comparisons)*
                differences
            }
        }
    })
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

In the above code, variables can be substituted in order to generate code by starting with a pound (`#`). For example, `#ident` will be replaced with ident from the `let let` variable. The `#(#comparisons)*` code expands the `let comparisons` variable which contains a `Vec<proc_macro2::TokenStream>` which is generated via the `quote::quote!` macro (which we'll look into in a minute). You can read more about [this syntax in the quote docs](https://docs.rs/quote/1.0.38/quote/macro.quote.html#interpolation). From the quote docs:

> Repetition is done using #(...)* or #(...),* again similar to macro_rules!. This iterates through the elements of any variable interpolated within the repetition and inserts a copy of the repetition body for each one. The variables in an interpolation may be a Vec, slice, BTreeSet, or any Iterator.

We skipped ahead of how we generated those comparisons. Let's go back and look at it now:

```rust
    let mut comparisons = Vec::new();
    for field in container.fields.iter() {
        let ParseField {
            ident,
            name,
            ..
        } = field;

        comparisons.push(quote::quote! {
            if self.#ident != old.#ident {
                differences.push(
                    format!("{name} ({old} to {new})",
                        name = #name,
                        old = &old.#ident,
                        new = &self.#ident,
                    )
                );
            }
        });
    }
    let (impl_generics, type_generics, where_clause) = generics.split_for_impl();
    Ok(quote::quote! {
        impl #impl_generics ::cache_diff::CacheDiff for #ident #type_generics #where_clause {
            fn diff(&self, old: &Self) -> ::std::vec::Vec<String> {
                let mut differences = ::std::vec::Vec::new();
                #(#comparisons)*
                differences
            }
        }
    })
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

In this code we're looping through all of the fields and pulling out the identifier (i.e. `version` for `version: String`), as well as the un-underscored name. Like we saw with the struct identifier, we will use the `quote::quote!` macro and the inner variables `ident` and `name` to check if the current value does not equal the old value, and if that happens then format that information and add it to the vec.

Unfortunately we cannot test the derive macro invocation in the same crate, because the macro must be compiled first. However, we can test it in our original crate.

We can use Rust's doctests to validate the happy path. At the top of `cache_diff/src/lib.rs` add module docs with a doctest that uses our derive macro:

```rust

// File: `cache_diff/src/lib.rs`
//! Cache Diff (derive)
//!
//! Generate the difference between two structs for the purposes of cache invalidation.
//!
//! Example:
//!
//! ```
//! use cache_diff::CacheDiff;
//!
//! #[derive(CacheDiff, Debug)]
//! struct Metadata {
//!     ruby_version: String,
//!     architecture: String,
//! }
//!
//! let diff = Metadata {ruby_version: "3.4.2".to_string(), architecture: "arm64".to_string()}
//!     .diff(&Metadata {ruby_version: "3.3.1".to_string(), architecture: "amd64".to_string()});
//!
//! assert_eq!(
//!     vec!["ruby version (3.3.1 to 3.4.2)".to_string(), "architecture (amd64 to arm64)".to_string()],
//!     diff
//! );
//! ```
// Use ...

// Code
// ...
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

This derive macro test is asserting the same behavior we implmemented manually before:

```rust
    impl CacheDiff for Metadata {
        fn diff(&self, old: &Self) -> Vec<String> {
            let mut diff = Vec::new();

            if self.ruby_version != old.ruby_version {
                diff.push(format!("ruby version ({} to {})",
                old.ruby_version,
                self.ruby_version))
            }
            if self.architecture != old.architecture {
                diff.push(
                    format!("architecture ({} to {})",
                    old.architecture,
                    self.architecture)
                )
            }
            diff
        }
    }

    #[test]
    fn test_changed_metadata() {
        let old = Metadata {
            ruby_version: "3.3.1".to_string(),
            architecture: "amd64".to_string()
        };
        let new = Metadata {
            ruby_version: "3.4.2".to_string(),
            architecture: "arm64".to_string()
        };

        assert_eq!(
            vec![
                "ruby version (3.3.1 to 3.4.2)".to_string(),
                "architecture (amd64 to arm64)".to_string()
            ],
            new.diff(&old)
        );
    }

    #[test]
    fn test_unchanged_metadata() {
        let old = Metadata {
            ruby_version: "3.1.4".to_string(),
            architecture: "amd64".to_string()
        };

        let diff = old.diff(&old);
        assert!(
            diff.is_empty(),
            "Expected diff to be empty but is {:?}",
            diff
        );
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Now verify it all works:

```
$ cargo test
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Great! If your project is failing or if the tests you added didn't run, here's the full project for reference:

<details>
  <summary>Full project</summary>

```
$ exa --tree --git-ignore .
.
├── cache_diff
│  ├── Cargo.toml
│  └── src
│     └── lib.rs
├── cache_diff_derive
│  ├── Cargo.toml
│  └── src
│     ├── lib.rs
│     ├── parse_container.rs
│     └── parse_field.rs
├── Cargo.lock
└── Cargo.toml
$ cat Cargo.toml
[workspace]
members = [
    "cache_diff",
    "cache_diff_derive"
]
resolver = "2"
$ cat cache_diff/Cargo.toml
[package]
name = "cache_diff"
version = "0.1.0"
edition = "2024"

[dependencies]
cache_diff_derive = { version = "0.1.0" , optional = true, path = "../cache_diff_derive" }

[features]
derive = ["dep:cache_diff_derive"]
default = ["derive"]
$ cat cache_diff_derive/Cargo.toml
[package]
name = "cache_diff_derive"
version = "0.1.0"
edition = "2024"

[dependencies]
# Turn Rust code into Tokens
quote = "1.0.37"
# Parse tokens into Rust code
syn = { version = "2.0.83", features = ["extra-traits"] }
proc-macro2 = "1.0.89"
[lib]
proc-macro = true
$ cat cache_diff/src/lib.rs
// File: `cache_diff/src/lib.rs`
//! Cache Diff (derive)
//!
//! Generate the difference between two structs for the purposes of cache invalidation.
//!
//! Example:
//!
//! ```
//! use cache_diff::CacheDiff;
//!
//! #[derive(CacheDiff, Debug)]
//! struct Metadata {
//!     ruby_version: String,
//!     architecture: String,
//! }
//!
//! let diff = Metadata {ruby_version: "3.4.2".to_string(), architecture: "arm64".to_string()}
//!     .diff(&Metadata {ruby_version: "3.3.1".to_string(), architecture: "amd64".to_string()});
//!
//! assert_eq!(
//!     vec!["ruby version (3.3.1 to 3.4.2)".to_string(), "architecture (amd64 to arm64)".to_string()],
//!     diff
//! );
//! ```
#[cfg(feature = "derive")]
pub use cache_diff_derive::CacheDiff;
// Code
pub trait CacheDiff {
    fn diff(&self, old: &Self) -> Vec<String>;
}

#[cfg(test)]
mod tests {
    // Test use
    use super::*;
    // Test code
    struct Metadata {
        ruby_version: String,
        architecture: String,
    }

    impl CacheDiff for Metadata {
        fn diff(&self, old: &Self) -> Vec<String> {
            let mut diff = Vec::new();

            if self.ruby_version != old.ruby_version {
                diff.push(format!("ruby version ({} to {})",
                old.ruby_version,
                self.ruby_version))
            }
            if self.architecture != old.architecture {
                diff.push(
                    format!("architecture ({} to {})",
                    old.architecture,
                    self.architecture)
                )
            }
            diff
        }
    }

    #[test]
    fn test_changed_metadata() {
        let old = Metadata {
            ruby_version: "3.3.1".to_string(),
            architecture: "amd64".to_string()
        };
        let new = Metadata {
            ruby_version: "3.4.2".to_string(),
            architecture: "arm64".to_string()
        };

        assert_eq!(
            vec![
                "ruby version (3.3.1 to 3.4.2)".to_string(),
                "architecture (amd64 to arm64)".to_string()
            ],
            new.diff(&old)
        );
    }

    #[test]
    fn test_unchanged_metadata() {
        let old = Metadata {
            ruby_version: "3.1.4".to_string(),
            architecture: "amd64".to_string()
        };

        let diff = old.diff(&old);
        assert!(
            diff.is_empty(),
            "Expected diff to be empty but is {:?}",
            diff
        );
    }
}
$ cat cache_diff_derive/src/lib.rs
// File: `cache_diff_derive/src/lib.rs`
mod parse_field;
mod parse_container;
use proc_macro::TokenStream;
use parse_container::ParseContainer;
use parse_field::ParseField;
// Code
pub(crate) const NAMESPACE: &str = "cache_diff";
pub(crate) const MACRO_NAME: &str = "CacheDiff";

#[proc_macro_derive(CacheDiff, attributes(cache_diff))]
pub fn cache_diff(item: TokenStream)
    -> TokenStream {
    create_cache_diff(item.into())
        .unwrap_or_else(syn::Error::into_compile_error)
        .into()
}

fn create_cache_diff(item: proc_macro2::TokenStream)
    -> syn::Result<proc_macro2::TokenStream> {
    let derive_input: syn::DeriveInput = syn::parse2(item)?;
    let container = ParseContainer::from_derive_input(&derive_input)?;
    let ident = &container.ident;
    let generics = &container.generics;

    let mut comparisons = Vec::new();
    for field in container.fields.iter() {
        let ParseField {
            ident,
            name,
            ..
        } = field;

        comparisons.push(quote::quote! {
            if self.#ident != old.#ident {
                differences.push(
                    format!("{name} ({old} to {new})",
                        name = #name,
                        old = &old.#ident,
                        new = &self.#ident,
                    )
                );
            }
        });
    }
    let (impl_generics, type_generics, where_clause) = generics.split_for_impl();
    Ok(quote::quote! {
        impl #impl_generics ::cache_diff::CacheDiff for #ident #type_generics #where_clause {
            fn diff(&self, old: &Self) -> ::std::vec::Vec<String> {
                let mut differences = ::std::vec::Vec::new();
                #(#comparisons)*
                differences
            }
        }
    })
}
$ cat cache_diff_derive/src/parse_field.rs
// File: `cache_diff_derive/src/parse_field.rs`
use crate::MACRO_NAME;
use syn::spanned::Spanned;
// Code
/// Field (i.e. `name: String`) of a container (struct) and its parsed attributes
/// i.e. `#[cache_diff(rename = "Ruby version")]`
#[derive(Debug)]
pub(crate) struct ParseField {
    /// The proc-macro identifier for a field i.e. `name: String` would be a programmatic
    /// reference to `name` that can be used along with `quote!` to produce code.
    pub(crate) ident: syn::Ident,
    /// What the user will see when this field differs and invalidates the cache
    /// i.e. `age: usize` will be `"age"`.
    pub(crate) name: String,
}

impl ParseField {
    pub(crate) fn from_field(field: &syn::Field) -> Result<Self, syn::Error> {
        let ident = field.ident.clone().ok_or_else(|| {
            syn::Error::new(
                field.span(),
                format!("{MACRO_NAME} can only be used on structs with named fields"),
            )
        })?;

        let name = ident.to_string().replace("_", " ");

        Ok(ParseField {
            ident,
            name,
        })
    }
}

#[cfg(test)]
mod tests {
    // Test use
    use super::*;
    // Test code
    #[test]
    fn test_parse_field_plain() {
        let field: syn::Field = syn::parse_quote! {
            ruby_version: String
        };

        let parsed = ParseField::from_field(&field).unwrap();
        assert_eq!("ruby version".to_string(), parsed.name);
    }

    #[test]
    fn test_requires_named_struct() {
        let field: syn::Field = syn::parse_quote! {()};

        let result = ParseField::from_field(&field);
        assert!(result.is_err(), "Expected an error, got {:?}", result);
        assert_eq!(
            format!("{}", result.err().unwrap()),
            r#"CacheDiff can only be used on structs with named fields"#
        );
    }
}
$ cat cache_diff_derive/src/parse_container.rs
// File: `cache_diff_derive/src/parse_container.rs`
use crate::parse_field::ParseField;
use crate::MACRO_NAME;
// Code
/// Container (i.e. struct Metadata { ... }) and its parsed attributes
/// i.e. `#[cache_diff( ... )]`
#[derive(Debug)]
pub(crate) struct ParseContainer {
    /// The proc-macro identifier for a container i.e. `struct Metadata { }` would be a programmatic
    /// reference to `Metadata` that can be used along with `quote!` to produce code.
    pub(crate) ident: syn::Ident,
    /// Info about generics, lifetimes and where clauses i.e. `struct Metadata<T> { name: T }`
    pub(crate) generics: syn::Generics,
    /// Fields (i.e. `name: String`) and their associated attributes i.e. `#[cache_diff(...)]`
    pub(crate) fields: Vec<ParseField>,
}

impl ParseContainer {
    pub(crate) fn from_derive_input(input: &syn::DeriveInput) -> Result<Self, syn::Error> {
        let ident = input.ident.clone();
        let generics = input.generics.clone();
        let fields = match input.data {
            syn::Data::Struct(syn::DataStruct {
                fields: syn::Fields::Named(syn::FieldsNamed { ref named, .. }),
                ..
            }) => named,
            _ => {
                return Err(syn::Error::new(
                    ident.span(),
                    format!("{MACRO_NAME} can only be used on named structs"),
                ))
            }
        }
        .into_iter()
        .map(ParseField::from_field)
        .collect::<Result<Vec<ParseField>, syn::Error>>()?;

        Ok(ParseContainer { ident, generics, fields })
    }
}

#[cfg(test)]
mod tests {
    // Test use
    use super::*;
    // Test code
    #[test]
    fn test_parses() {
        let container = ParseContainer::from_derive_input(&syn::parse_quote! {
            struct Metadata {
                version: String
            }
        })
        .unwrap();
        assert_eq!(1, container.fields.len());

        let container = ParseContainer::from_derive_input(&syn::parse_quote! {
            struct Metadata {
                version: String,
                checksum: String
            }
        })
        .unwrap();
        assert_eq!(2, container.fields.len());
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->
</details>

Great! Our macro needs to be able to handle any possible valid Rust code input. You may have noticed we needed to explicitly extract information about generics and use that to generate our trait:

```rust
    let (impl_generics, type_generics, where_clause) = generics.split_for_impl();
    Ok(quote::quote! {
        impl #impl_generics ::cache_diff::CacheDiff for #ident #type_generics #where_clause {
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

To verify that our code works with generics you can add a test for that behavior:

```rust
//!
//! #{BACKTICKS}
//! use cache_diff::CacheDiff;
//!
//! #[derive(CacheDiff, Debug)]
//! struct Metadata<T> {
//!     ruby_version: String,
//!     architecture: T,
//! }
//!
//! let diff = Metadata<String> {ruby_version: "3.4.2".to_string(), architecture: "arm64".to_string()}
//!     .diff(&Metadata<String> {ruby_version: "3.3.1".to_string(), architecture: "amd64".to_string()});
//!
//! assert_eq!(
//!     vec!["ruby version (3.3.1 to 3.4.2)".to_string(), "architecture (amd64 to arm64)".to_string()],
//!     diff
//! );
//! #{BACKTICKS}
EOF
%>
<%= append(filename: "cache_diff/src/lib.rs", module_docs: module_docs) %>
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Congrats! You just wrote a derive macro! But we're not done yet. Now, that we have the base functionality in place, let's look a little bit a derive macro attributes so we can make our trait Derive easy to customize.
<span id="chapter_06" />

## 06: Understanding attributes for Derive customization

> [Skip](#chapter_07) this if: You are familiar with derive macro configuration via field and container attributes.

A derive macro lets us implement traits on data structures with sensible defaults, but what happens when we want something more custom? For that, we'll use attributes.

The [`serde`](https://serde.rs/) crate is a (ser)ialiazation/(de)serialization library that ships with derive macros and is customizable via attributes. Here's an example using [v1.0.218](https://docs.rs/serde/1.0.218/serde/index.html):

```rust
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
struct Metadata {
    version: String,
    architecture: String,
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

And with attributes:

```rust
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
#[serde(deny_unknown_fields)] // <== HERE
struct Metadata {
    #[serde(rename = "ruby_version")] // <== HERE
    version: String,
    architecture: String,
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

In this code, `#[serde(rename = "ruby_version")]` is an attribute on the field `version: String`. When serializing, this [rename attribute](https://serde.rs/field-attrs.html) overwrites the default field name. The `#[serde(deny_unknown_fields)]` at the top is an attribute on the container, `Metadata`. This attribute of serde [errors if you try to deserialize a field it's not expecting](https://serde.rs/container-attrs.html). We can use this same attribute concept to customize the behavior of our `CacheDiff` trait generation.

It's the convention to name your attribute a [snake cased](https://en.wikipedia.org/wiki/Snake_case) name of your trait. We will use the `#[cache_diff(...)]` attribute namespace. Technically, we could use any format or DSL for the inside of the attribute, but it's usually a good idea to mimic existing interfaces that people are already comfortable with. Most attributes take `<key> = <value>` and `<stand-alone-key>` formats. So that's what we'll use.

To recap:

- A container attribute operates on a data structure like `struct Metadata`.
- A field attribute operates on an individual field of that data structure like `version: String`.

Another type of attribute called "variant attributes" applies to enum variants, but we won't be using them in this tutorial.

### Explore the interface space by hand

The attribute interface will be an important interaction point with your macro's users. Spend a moment considering how you want the final project to look from our users' perspective. Rather than adding arbitrary configuration options, implementing a rough prototype and seeing where the edges are can help guide the needed features.

In the real world, I prototyped the `CacheDiff` trait and implemented it manually for several [layers](https://buildpacks.io/docs/for-buildpack-authors/concepts/layer/) across three different buildpacks to understand the problem space. Doing this without jumping into the macro code helped me understand the edge cases.

### Explore: Don't ignore the signs

One of my structs had some data that I wasn't using as a cache key for invalidation, it was recording the number of times the cache had been written to, when it changed I didn't want that to invalidate the cache. This experience informed me that I should have a way of skipping or ignoring fields that shouldn't be considered cache keys.

### Explore: Display play

Another struct contained a [`std::path::PathBuf`](https://doc.rust-lang.org/std/path/struct.PathBuf.html) that should invalidate the cache when it changed. If you've worked with Rust for awhile you might guess the problem, if not I'll spoil the surprise: this type does not directly implement [std::fmt::Display](https://doc.rust-lang.org/std/fmt/trait.Display.html).

That means you cannot directly use it in a `format!()` or `println!()` macro or it will error.  If you try to run this code:

```rust
fn main() {
    println!(
    "Cannot display Path directly {}",
    std::path::PathBuf::from("src/lib.rs")
    );
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Then it will produce this error:

```
   Compiling lol v0.1.0 (/private/var/folders/yr/yytf3z3n3q336f1tj2b2j0gw0000gn/T/d20250318-97315-gjz2i5/lol)
error[E0277]: `PathBuf` doesn't implement `std::fmt::Display`
 --> src/main.rs:4:5
  |
4 |     std::path::PathBuf::from("src/lib.rs")
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `PathBuf` cannot be formatted with the default formatter; call `.display()` on it
  |
  = help: the trait `std::fmt::Display` is not implemented for `PathBuf`
  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
  = note: call `.display()` or `.to_string_lossy()` to safely print paths, as they may contain non-Unicode data
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0277`.
error: could not compile `lol` (bin "lol" test) due to 1 previous error
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

The [std::path::PathBuf::display() function docs](https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.display) show how you can call `display()` on it to print or format the value.

This use case tells me that I need to provide a way for developers to specify how to `Display` a value even if the type they're using as a cache key doesn't implement it directly.

### Explore: Doc-driven design

With those two use cases in mind, we can explore what the interface could look like. We'll use the `Metadata` struct from earlier. We don't have any attribute code yet, but we're going to write some pseudo code of what the interface could look like. This is sometimes called README-driven design or documentation-driven design.

Before, we saw that an attribute could be a single key like `#[serde(deny_unknown_fields)]`. Since our project is named `CacheDiff`, we could implement an `ignore` key like:

```rust
use cache_diff::CacheDiff;

#[derive(CacheDiff)]
struct Metadata {
    ruby_version: String,
    architecture: String,

    #[cache_diff(ignore)] // <== HERE
    cache_count: usize
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Looks great. Now, how could we configure a custom display function? For that we'll need to use a key and value like we saw with `#[serde(rename = "ruby_version")]` but unlike that interface we don't want to configure a static string, we want to give it a path to a dynamic function, thankfully that's possible. We could have the API for that interface look somewhat like this:

```rust
use cache_diff::CacheDiff;

#[derive(CacheDiff)]
struct Metadata {
    ruby_version: String,
    architecture: String,

    #[cache_diff(display = std::path::PathBuf::display)] // <== HERE
    binary_location: std::path::PathBuf
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

In this code:

```rust
#[cache_diff(display = std::path::PathBuf::display)]
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

The attribute key will be `display` and the path to the function we want to use will be `std::path::PathBuf::display` which is a [function](https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.display).

These are sketches of what the code could look like. Here's the IRL README docs that I wrote for these two attributes:

- [Field attribute: `cache_diff(ignore)`](https://github.com/heroku-buildpacks/cache_diff/blob/fc854c0a1f0e89868bf3d822611dd21229af46f3/cache_diff/README.md#ignore-attributes)
- [Field attribute: `cache_diff(display = <code path>)`](https://github.com/heroku-buildpacks/cache_diff/blob/fc854c0a1f0e89868bf3d822611dd21229af46f3/cache_diff/README.md#handle-structs-missing-display)

In addition to these customizations, users also want:

- [The ability to rename fields. Field attribute: `cache_diff(rename = "<new name>")`](https://github.com/heroku-buildpacks/cache_diff/blob/fc854c0a1f0e89868bf3d822611dd21229af46f3/cache_diff/README.md#rename-attributes)
- [Customize cache behavior for some fields without manually implementing the trait for the rest. Container attribute: `cache_diff(custom = <code path>)`](hhttps://github.com/heroku-buildpacks/cache_diff/blob/fc854c0a1f0e89868bf3d822611dd21229af46f3/cache_diff/README.md#custom-logic-for-one-field-example)

Now that we know what we want the destination to look like, we're ready to modify our code to support attributes!

<span id="chapter_07" />

## 07: Add attributes to ParseField

Our macro will need both field and container attributes. Our readme-driven development left us with three things to customize on the field:

- [cache_diff(ignore)](https://github.com/heroku-buildpacks/cache_diff/blob/fc854c0a1f0e89868bf3d822611dd21229af46f3/cache_diff/README.md#ignore-attributes)
- [cache_diff(display = <code path>)](https://github.com/heroku-buildpacks/cache_diff/blob/fc854c0a1f0e89868bf3d822611dd21229af46f3/cache_diff/README.md#handle-structs-missing-display)
- [cache_diff(rename = "<new name>")](https://github.com/heroku-buildpacks/cache_diff/blob/fc854c0a1f0e89868bf3d822611dd21229af46f3/cache_diff/README.md#rename-attributes)

And one thing to customize on the container:

- [Customize cache behavior for some fields without manually implementing the trait for the rest. Container attribute: `cache_diff(custom = <code path>)`](hhttps://github.com/heroku-buildpacks/cache_diff/blob/fc854c0a1f0e89868bf3d822611dd21229af46f3/cache_diff/README.md#custom-logic-for-one-field-example)

Initial prototyping suggested that it was helpful for developers to list why a specific field was ignored, so beyond a simple boolean flag for ignore, I decided that `cache_diff(ignore = "Reason why the field is ignored")` should also be valid.

Like before, we'll represent this state in code and fill out the rest of our program to be capable of generating that code. We will represent individual attributes as an enum and use the [strum](https://crates.io/crates/strum) crate to simplify parsing and error generation. Add that dependency now:

```
$ cargo add strum@0.27.1 --package cache_diff_derive --features derive
$ cargo add strum@0.27.1 --package cache_diff_derive --features derive --offline
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

The dependencies look like this:

```
$ cat cache_diff_derive/Cargo.toml
[package]
name = "cache_diff_derive"
version = "0.1.0"
edition = "2024"

[dependencies]
# Turn Rust code into Tokens
quote = "1.0.37"
# Parse tokens into Rust code
syn = { version = "2.0.83", features = ["extra-traits"] }
proc-macro2 = "1.0.89"
strum = { version = "0.27.1", features = ["derive"] }
[lib]
proc-macro = true
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Now, define an enum that will hold each of our attribute variants. Add this code:

```rust

// File: `cache_diff_derive/src/parse_field.rs`
// Use ...
use std::str::FromStr;
use strum::IntoEnumIterator;
// Code
// ...
/// A single attribute
#[derive(strum::EnumDiscriminants, Debug, PartialEq)]
#[strum_discriminants(
    name(KnownAttribute),
    derive(strum::EnumIter, strum::Display, strum::EnumString, Hash)
)]
enum ParseAttribute {
    #[allow(non_camel_case_types)]
    rename(String), // #[cache_diff(rename="...")]
    #[allow(non_camel_case_types)]
    display(syn::Path), // #[cache_diff(display=<function>)]
    #[allow(non_camel_case_types)]
    ignore(String), // #[cache_diff(ignore)]
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

In addition to enum variants such as `ParseAttribute::rename(...)`, the strum crate creates a "discriminant" enum with the same named variants but without input values. That means that `ParseAttribute::rename(String)` will have a corresponding `KnownAttribute::rename` (without the `String` inner value).

We're using `strum_discriminants` attribute to tell strum to name this "discriminant" enum `KnownAttribute` and give it the ability to iterate over all its variants (`strum::EnumIter`), print the name of each variant (`strum::Display`), and generate a variant from a string (`strum::EnumString`).

Attributes parse logic is similar so that we can reuse some of the logic in our field and container parsing. Create a new file and add this code:

```rust
// File: `cache_diff_derive/src/shared.rs`
use crate::{MACRO_NAME, NAMESPACE};
use std::{collections::HashMap, fmt::Display, str::FromStr};
// Code
/// Parses one bare word like "rename" for any iterable enum, and that's it
///
/// Won't parse an equal sign or anything else
pub(crate) fn known_attribute<T>(identity: &syn::Ident) -> syn::Result<T>
where
    T: FromStr + strum::IntoEnumIterator + Display,
{
    let name_str = &identity.to_string();
    T::from_str(name_str).map_err(|_| {
        syn::Error::new(
            identity.span(),
            format!(
                "Unknown {NAMESPACE} attribute: `{identity}`. Must be one of {valid_keys}",
                valid_keys = T::iter()
                    .map(|key| format!("`{key}`"))
                    .collect::<Vec<String>>()
                    .join(", ")
            ),
        )
    })
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

This code takes in a `syn::Ident` described in the docs as "A word of Rust code, which may be a keyword or legal variable name." This `syn::Ident` struct holds any single bare word like `struct` or `let` or anything that could be a valid variable name like `rename`. The return result will be the discriminant `KnownAttribute` we defined earlier. However, since it is generic, we can reuse it to produce any type with the same behaviors (traits). The traits on it tell us that we must be able to construct this value from a str (`FromStr`). It must be an iterable enum (`strum::IntoEnumIterator`). And it needs to be a thing we can show our end user (`Display`).

The body extracts a string from our bare word and uses the `FromStr` trait to try to produce an enum fallibly. If it fails, we emit a nice parse error explaining what values are valid so the user doesn't have to stop and look up our docs.

Make sure your project knows about this new code by adding this file:

```rust
// File: `cache_diff_derive/src/lib.rs`
// Mod ...
mod shared;
// Use ...

// Code
// ...
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

We will implement the `syn::parse::Parse` trait to allow syn to parse a stream of tokens into our data structures. We'll start with our `KnownAttribute` enum. Add this code:

```rust
// File: `cache_diff_derive/src/parse_field.rs`
// Use ...

// Code
// ...
impl syn::parse::Parse for KnownAttribute {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let identity = input.parse::<syn::Ident>()?;
        crate::shared::known_attribute(&identity)
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

This code takes in a `syn::parse::ParseStream`. From the docs on that module:

```
> Parsing interface for parsing a token stream into a syntax tree node.
>
> Parsing in Syn is built on parser functions that take in a [`ParseStream`]
> and produce a [`Result<T>`] where `T` is some syntax tree node.
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

So, a `ParseStream` could represent tokens in valid or invalid rust code. It has a `parse` function on it, and we can use that function to parse into any `T` that implements `syn::parse::ParseStream` such as `syn::Ident`, which we are doing here. We pass that ident into the `crate::shared::known_attribute` function we just defined.

To see it in action, add a test now:

```rust
// File: `cache_diff_derive/src/parse_field.rs`
// Use ...

// Code
// ...

#[cfg(test)]
mod tests {
    // Test use
    // ...

    // Test code
    // ...
    #[test]
    fn test_known_attributes() {
        let parsed: KnownAttribute = syn::parse_str("rename").unwrap();
        assert_eq!(KnownAttribute::rename, parsed);

        let parsed: KnownAttribute = syn::parse_str("ignore").unwrap();
        assert_eq!(KnownAttribute::ignore, parsed);

        let parsed: KnownAttribute = syn::parse_str("display").unwrap();
        assert_eq!(KnownAttribute::display, parsed);

        let result: Result<KnownAttribute, syn::Error> = syn::parse_str("unknown");
        assert!(result.is_err(), "Expected an error, got {:?}", result);
        assert_eq!(
            format!("{}", result.err().unwrap()),
            r#"Unknown cache_diff attribute: `unknown`. Must be one of `rename`, `display`, `ignore`"#
        );
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

This test uses `syn::parse_str` to take in single keywords we defined, such as "rename," and convert them into a `KnownAttribute` enum variant. The syn crate can do this because we implemented `syn::parse::Parse` on this `KnownAttribute` enum. You can also see our nice error message when we try to parse `unknown`. There is no discriminant `KnownAttribute::unknown` because there is no `ParseAttribute::unknown(...)` variant.

In addition to errors we manually added, there are other ways for parsing to fail:

```rust
#[test]
    fn test_other_error_cases() {
        let result: Result<KnownAttribute, syn::Error> = syn::parse_str("'iamnotanident'");
        assert!(result.is_err(), "Expected an error, got {:?}", result);
        assert_eq!(
            format!("{}", result.err().unwrap()),
            r#"cannot parse string into token stream"#
        );

        let result: Result<KnownAttribute, syn::Error> = syn::parse_str("rename and more!");
        assert!(result.is_err(), "Expected an error, got {:?}", result);
        assert_eq!(
            format!("{}", result.err().unwrap()),
            r#"unexpected token"#
        );
    }
CODE
%>
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

The first error is because `input.parse::<syn::Ident>()?` is expecting a bare word, not a string, so it errors. The second error happens because we passed in more tokens than our parser could use. It could parse `rename` and turn it into a `KnownAttribute::rename` variant, but after that, there's still `and more !` left in the parse stream.

Syn requires that all tokens are consumed in the body of a `syn::parse::Parse` implementation, or it will raise an error. This behavior prevents accidentally taking in input that we're not expecting. Unfortunately, the error message isn't clear in the test context. If you get "unexpected token" when you're prototyping your macro, you'll need to add some `eprintln!` calls to understand what's happening inside your parse implementation.

We will use this capability to generate an implementation of `syn::parse::Parse` for our `ParseAttribute` to allow it to handle a `<key> = <value>` structure. Add this code:

```rust
// File: `cache_diff_derive/src/parse_field.rs`
// Use ...

// Code
// ...
impl syn::parse::Parse for ParseAttribute {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let key: KnownAttribute = input.parse()?;

        match key {
            KnownAttribute::rename => {
                input.parse::<syn::Token![=]>()?;
                Ok(ParseAttribute::rename(
                    input.parse::<syn::LitStr>()?.value(),
                ))
            }
            KnownAttribute::display => {
                input.parse::<syn::Token![=]>()?;
                Ok(ParseAttribute::display(input.parse()?))
            }
            KnownAttribute::ignore => {
                if input.peek(syn::Token![=]) {
                    input.parse::<syn::Token![=]>()?;
                    Ok(ParseAttribute::ignore(
                        input.parse::<syn::LitStr>()?.value(),
                    ))
                } else {
                    Ok(ParseAttribute::ignore("default".to_string()))
                }
            }
        }
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Because we previously implemented `syn::parse::Parse` for `KnownAttribute`, we can parse the input and then match against the enum. When a `syn::parse::ParseStream` is parsed successfully, then that part of the stream is consumed. That means that in the case of `rename` and `display`, we require that the user gives us an equal sign next. This can be parsed using `syn::Token![=]`:

```rust
input.parse::<syn::Token![=]>()?;
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

After the equal sign is parsed, parse the value. A `syn::LitStr` struct can hold a string with quotes. For an input of `rename = "Ruby VERSION"` the `syn::LitStr` will capture `"Ruby VERSION"`. We can extract a string from a `syn::LitStr` by calling the `.value()` associated function:

```rust
Ok(ParseAttribute::rename(
    input.parse::<syn::LitStr>()?.value(),
))
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

The `display` attribute holds a `syn::Path`, which is described as "A path at which a named item is exported." This type allows us to accept a function like `my_display` or a fully qualified path to a function like: `std::path::PathBuf::display`. Because this is a syn type, we can parse directly into it without needing any type annotations:

```rust
Ok(ParseAttribute::display(input.parse()?))
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Finally, the `ignore` attribute can be used in one of two ways: either `cache_diff(ignore)` or `cache_diff(ignore = "reason")`. To handle these two scenarios, we can inspect the `ParseStream` via `peek()` to see if it contains an equal. If it does, parse it and expect a literal string afterward. If not, we'll default to some internal value. So far, the value is only used as a marker in the source for future developers to explain why it was ignored so we could choose any default string. I picked "no reason given":


```rust
KnownAttribute::ignore => {
    if input.peek(syn::Token![=]) {
        input.parse::<syn::Token![=]>()?;
        Ok(ParseAttribute::ignore(
            input.parse::<syn::LitStr>()?.value(),
        ))
    } else {
        Ok(ParseAttribute::ignore("no reason given".to_string()))
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

With all that in place, you can add a test and validate that we can parse it into our data structure. Add this code:

```rust
// File: `cache_diff_derive/src/parse_field.rs`
// Use ...

// Code
// ...

#[cfg(test)]
mod tests {
    // Test use
    // ...

    // Test code
    // ...
    #[test]
    fn test_parse_attributes() {
        let parsed: ParseAttribute = syn::parse_str(r#"rename = "Ruby version""#).unwrap();
        assert_eq!(ParseAttribute::rename("Ruby version".to_string()), parsed);

        let parsed: ParseAttribute = syn::parse_str(r#"display= my_function"#).unwrap();
        assert!(matches!(parsed, ParseAttribute::display(_))); let parsed: ParseAttribute = syn::parse_str(r#"ignore = "i have my reasons""#).unwrap();
        assert!(matches!(parsed, ParseAttribute::ignore(_)));

        let parsed: ParseAttribute = syn::parse_str("ignore").unwrap();
        assert!(matches!(parsed, ParseAttribute::ignore(_)));
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

So far, so good, but if you tried to parse multiple attributes like `rename = "ruby version", display = my_function`, then you'll get a failure. Why? Because `ParseAttribute` only parses a single attribute at a time. It would consume `rename = "ruby version"` but leave `, display = my_function` untouched.

To parse a comma-separated set of attributes, add this code:

```rust
// File: `cache_diff_derive/src/shared.rs`
// Use ...

// Code
// ...
fn parse_attrs<T>(attrs: &[syn::Attribute]) -> Result<Vec<T>, syn::Error>
where
    T: syn::parse::Parse,
{
    let mut attributes = Vec::new();
    for attr in attrs.iter().filter(|attr| attr.path().is_ident(NAMESPACE)) {
        for attribute in attr.parse_args_with(
            syn::punctuated::Punctuated::<T, syn::Token![,]>::parse_terminated,
        )? {
            attributes.push(attribute)
        }
    }

    Ok(attributes)
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

This code pulls out attributes on a field and iterates over them. The `syn` code receives ALL attributes, so we have to filter by our macro's namespace, or else we'll accidentally try to parse things like `serde(...)` attributes from other macros. This loop will yield a `syn::Attribute`:

```rust
    for attr in attrs.iter().filter(|attr| attr.path().is_ident(NAMESPACE)) {
// ... attr is a syn::Attribute
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

We use the [`syn::Attribute::parse_args_with`](https://docs.rs/syn/latest/syn/struct.Attribute.html#method.parse_args_with) function, which takes a parser. We've implemented two parsers: `KnownAttribute` and `ParseAttribute`. But we need something that can handle a comma-separated set of attributes, so we turn to the pre-built `syn::punctuated::Punctuated` parser, which is a parser combinator, meaning it takes in other parsers as its input. In our case, we're telling it to build a set of `ParseAttribute` enums and use commas (`syn::Token![,]`) to separate them. We then call `parse_terminated` on this parser combinator, which returns an iterator of item type `ParseAttribute` that we can use to build and return our `Vec<ParseAttribute>`:

```rust
        for attribute in attr.parse_args_with(
            syn::punctuated::Punctuated::<T, syn::Token![,]>::parse_terminated,
        )? {
            attributes.push(attribute)
        }
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

And add a test for the behavior:

```rust
// File: `cache_diff_derive/src/shared.rs`
// Use ...

// Code
// ...

#[cfg(test)]
mod tests {
    // Test use
    use super::*;
    // Test code
    #[test]
    fn test_parse_attrs_vec_demo() {
        let field: syn::Field = syn::parse_quote! {
            #[cache_diff("Ruby version")]
            name: String
        };

        assert_eq!(
            vec![syn::parse_str::<syn::LitStr>(r#""Ruby version""#).unwrap()],
            parse_attrs::<syn::LitStr>(&field.attrs).unwrap()
        );
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

While our `T` will eventually be `ParseAttribute`, this unit test exercises the behavior using another struct that implements `syn::parse::Parse` that we saw earlier, `syn::LitStr`. This test represents syntax that is not valid in our final macro (we don't accept a string literal "Ruby version" without any `<key> =` before it). This test shows how this function can be used as a building block with any struct that implements `syn::parse::Parse`.

At this point, we've added the ability to extract any cache_diff attributes from a `syn::Field` as a `Vec<T>` such as `Vec<ParseAttribute>`, but there's nothing stopping someone from accidentally using a duplicate configuration such as `cache_diff(rename = "Ruby", rename = "Rust")`. To prevent that and raise nice errors, we can use a different iterator that guarantees all entries are unique [`std::collections::HashMap](https://doc.rust-lang.org/std/collections/struct.HashMap.html) (rather than a `Vec` which can hold repeated entries). The discriminant of our attributes `KnownAttribute` already implements `Hash`, so we can use this as a key. The value will hold a `ParseAttribute` and span information to pinpoint precisely where an attribute was duplicated in the code. For that span information, create a helper struct.

Add this code:

```rust
// File: `cache_diff_derive/src/shared.rs`
// Use ...

// Code
// ...
/// Helper type for parsing a type and preserving the original span
///
/// Used with [syn::punctuated::Punctuated] to capture the inner span of an attribute.
#[derive(Debug)]
pub(crate) struct WithSpan<T>(pub(crate) T, pub(crate) proc_macro2::Span);

impl<T> WithSpan<T> {
    pub(crate) fn into_inner(self) -> T {
        self.0
    }
}

impl<T: syn::parse::Parse> syn::parse::Parse for WithSpan<T> {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let span = input.span();
        Ok(WithSpan(input.parse()?, span))
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

This new `WithSpan` struct can hold any `impl syn::parse::Parse` value, such as `ParseAttribute` or a `syn::LitStr`, as we saw in the tests before. Verify that behavior by adding a test:

```rust
// File: `cache_diff_derive/src/shared.rs`
// Use ...

// Code
// ...

#[cfg(test)]
mod tests {
    // Test use
    // ...
use super::*;
    // Test code
    // ...
    #[test]
    fn test_parse_attrs_with_span_vec_demo() {
        let field: syn::Field = syn::parse_quote! {
            #[cache_diff("Ruby version")]
            name: String
        };

        assert_eq!(
            &syn::parse_str::<syn::LitStr>(r#""Ruby version""#).unwrap(),
            parse_attrs::<WithSpan<syn::LitStr>>(&field.attrs)
                .unwrap()
                .into_iter()
                .map(WithSpan::into_inner)
                .collect::<Vec<_>>()
                .first()
                .unwrap()
        );
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Now, we have the building blocks for a generic function with the properties we want. Add this code now:

```rust
// File: `cache_diff_derive/src/shared.rs`
// Use ...

// Code
// ...
/// Parses all attributes and returns a lookup with the parsed value and span information where it was found
///
/// - Guarantees attributes are not duplicated
pub(crate) fn attribute_lookup<T>(
    attrs: &[syn::Attribute],
) -> Result<HashMap<T::Discriminant, WithSpan<T>>, syn::Error>
where
    T: strum::IntoDiscriminant + syn::parse::Parse,
    T::Discriminant: Eq + Display + std::hash::Hash + Copy,
{
    let mut seen = HashMap::new();
    let parsed_attributes = parse_attrs::<WithSpan<T>>(attrs)?;
    for attribute in parsed_attributes {
        let WithSpan(ref parsed, span) = attribute;
        let key = parsed.discriminant();
        if let Some(WithSpan(_, prior)) = seen.insert(key, attribute) {
            let mut error =
                syn::Error::new(span, format!("{MACRO_NAME} duplicate attribute: `{key}`"));
            error.combine(syn::Error::new(
                prior,
                format!("previously `{key}` defined here"),
            ));
            return Err(error);
        }
    }

    Ok(seen)
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

This function signature enforces the behavior we want via types and traits:

```rust
pub(crate) fn attribute_lookup<T>(
    attrs: &[syn::Attribute],
) -> Result<HashMap<T::Discriminant, WithSpan<T>>, syn::Error>
where
    T: strum::IntoDiscriminant + syn::parse::Parse,
    T::Discriminant: Eq + Display + std::hash::Hash + Copy,
{
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Like `parse_attrs`, it takes in the `&[syn::Attribute]` slice from the `syn::Field`, but the return value enforces that `T` (such as the enum `ParseAttribute`) must implement `strum::IntoDiscriminant` and `syn::parse::Parse` and that the key must be a discriminant of `T`. Storing that in a `HashMap` guarantees we will have at most one `KnownAttribute`, which maps to one `WithSpan<ParseAttribute>`. I returned the `WithSpan<T>` instead of `T` as this function only enforces that attributes are unique. In the future, an author may want to add additional constraints, such as raising an error when `ignore` is used with an attribute such as `rename`, which would imply a mistake by the implementer as `rename` would have no effect due to `ignore`.

Inside the function, a vec of all attributes is built and iterated over:

```rust
    let parsed_attributes = parse_attrs::<WithSpan<T>>(attrs)?;
    for attribute in parsed_attributes {
        let WithSpan(ref parsed, span) = attribute;
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

We try inserting the attribute into the HashMap based on the discriminant key:

```rust
        if let Some(WithSpan(_, prior)) = seen.insert(key, attribute) {
            let mut error =
                syn::Error::new(span, format!("{MACRO_NAME} duplicate attribute: `{key}`"));
            error.combine(syn::Error::new(
                prior,
                format!("previously `{key}` defined here"),
            ));
            return Err(error);
        }
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

If a prior entry exists, it represents an error, as each attribute should only have one representation. Here, we are using [syn::Error::combine](https://docs.rs/syn/latest/syn/struct.Error.html#method.combine) to create two errors effectively, the first points at the most recent attribute we tried to add, while the last points at the attribute that was already in the HashMap. The result will look something like:

```
error: CacheDiff duplicate attribute: `rename`
 --> tests/fails/duplicate_attribute.rs:5:34
  |
5 |     #[cache_diff(rename = "foo", rename = "bar")]
  |                                  ^^^^^^

error: previously `rename` defined here
 --> tests/fails/duplicate_attribute.rs:5:18
  |
5 |     #[cache_diff(rename = "foo", rename = "bar")]
  |                  ^^^^^^
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Now, I want to ensure that all of these attributes in our `HashMap` go somewhere. I don't want the programmer to add an attribute that successfully parses but has no effect because they forgot to look it up. To raise a nice error in that situation, I'll assume that when a key is looked up, it will be removed from the HashMap. That means when we're done consuming all attributes, the HashMap should be empty. Add code to raise an error if it's not:

```rust
// File: `cache_diff_derive/src/shared.rs`
// Use ...

// Code
// ...
pub(crate) fn check_empty<T>(lookup: HashMap<T::Discriminant, WithSpan<T>>) -> syn::Result<()>
where
    T: strum::IntoDiscriminant,
    T::Discriminant: Display + std::hash::Hash,
{
    if lookup.is_empty() {
        Ok(())
    } else {
        let mut error = syn::Error::new(
            proc_macro2::Span::call_site(),
            "Internal error: The developer forgot to implement some logic",
        );
        for (key, WithSpan(_, span)) in lookup.into_iter() {
            error.combine(syn::Error::new(
                span,
                format!("Attribute `{key}` parsed but not used"),
            ));
        }
        Err(error)
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

At this point, we've added the ability to extract any cache_diff attributes from a `syn::Field` as a `HashMap<KnownAttribute, WithSpan<ParseAttribute>>`, but so far, nothing uses `ParseAttribute`. We need to put this information into a `ParseField` to make it useful. Replace this code:

```rust
// File: `cache_diff_derive/src/parse_field.rs`
// Use ...

// Code
// ...
/// Field (i.e. `name: String`) of a container (struct) and its parsed attributes
/// i.e. `#[cache_diff(rename = "Ruby version")]`
#[derive(Debug)]
pub(crate) struct ParseField {
    /// The proc-macro identifier for a field i.e. `name: String` would be a programmatic
    /// reference to `name` that can be used along with `quote!` to produce code.
    pub(crate) ident: syn::Ident,
    /// What the user will see when this field differs and invalidates the cache
    /// i.e. `age: usize` will be `"age"`.
    pub(crate) name: String,
}


```

With with these new contents:


```rust
// File: `cache_diff_derive/src/parse_field.rs`
// Use ...

// Code
// ...
/// Field (i.e. `name: String`) of a container (struct) and its parsed attributes
/// i.e. `#[cache_diff(rename = "Ruby version")]`
#[derive(Debug)]
pub(crate) struct ParseField {
    /// The proc-macro identifier for a field i.e. `name: String` would be a programmatic
    /// reference to `name` that can be used along with `quote!` to produce code.
    pub(crate) ident: syn::Ident,
    /// What the user will see when this field differs and invalidates the cache
    /// i.e. `age: usize` will be `"age"`.
    pub(crate) name: String,
    /// Whether or not the field is included in the derived diff comparison
    pub(crate) ignore: Option<String>,
    /// The function to use when rendering values on the field
    /// i.e. `age: 42` will be `"42"`
    pub(crate) display: syn::Path,
}


```

We were already storing the ID and desired name of our field, but now we're also capturing whether it was ignored and what function to use for its display.

Since this last field, `display`, isn't optional, we'll need to set it for every `ParseField`. But how can we do that since `display` is optional? To help with this problem, a nifty utility function [`std::convert::identity`](https://doc.rust-lang.org/std/convert/fn.identity.html) that returns whatever is passed to it, we will use that as a default. And while we're picking out sensible defaults, if we can detect that a type is a `std::path::PathBuf`, then we can go ahead and default to `std::path::PathBuf::display` since we know paths do not implement `Display` by default.

Add this helper function now:

```rust
// File: `cache_diff_derive/src/parse_field.rs`
// Use ...

// Code
// ...
fn is_pathbuf(ty: &syn::Type) -> bool {
    if let syn::Type::Path(type_path) = ty {
        if let Some(segment) = type_path.path.segments.last() {
            return segment.ident == "PathBuf" && segment.arguments == syn::PathArguments::None;
        }
    }
    false
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

This code takes in a `syn::Type` and checks if it's a path to a type. If it is and matches `PathBuf`, then it returns true. Perhaps there's a more robust way to check; if you know one, let me know. With that helper code in place, we can now extract values to build our new `ParseField`.

Import the helper struct:

```rust
// File: `cache_diff_derive/src/parse_field.rs`
// Use ...
use crate::shared::WithSpan;
// Code
// ...
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Replace this code:

```rust
// File: `cache_diff_derive/src/parse_field.rs`
// Use ...

// Code
// ...
impl ParseField {
    pub(crate) fn from_field(field: &syn::Field) -> Result<Self, syn::Error> {
        let ident = field.ident.clone().ok_or_else(|| {
            syn::Error::new(
                field.span(),
                format!("{MACRO_NAME} can only be used on structs with named fields"),
            )
        })?;

        let name = ident.to_string().replace("_", " ");

        Ok(ParseField {
            ident,
            name,
        })
    }
}


```

With with these new contents:


```rust
// File: `cache_diff_derive/src/parse_field.rs`
// Use ...

// Code
// ...
impl ParseField {
    pub(crate) fn from_field(field: &syn::Field) -> Result<Self, syn::Error> {
        let ident = field.ident.clone().ok_or_else(|| {
            syn::Error::new(
                field.span(),
                format!("{MACRO_NAME} can only be used on structs with named fields"),
            )
        })?;

        let mut lookup = crate::shared::attribute_lookup::<ParseAttribute>(&field.attrs)?;
        let name = lookup
            .remove(&KnownAttribute::rename)
            .map(WithSpan::into_inner)
            .map(|parsed| match parsed {
                ParseAttribute::rename(inner) => inner,
                _ => unreachable!(),
            })
            .unwrap_or_else(|| ident.to_string().replace("_", " "));
        let display = lookup
            .remove(&KnownAttribute::display)
            .map(WithSpan::into_inner)
            .map(|parsed| match parsed {
                ParseAttribute::display(inner) => inner,
                _ => unreachable!(),
            })
            .unwrap_or_else(|| {
                if is_pathbuf(&field.ty) {
                    syn::parse_str("std::path::Path::display")
                        .expect("PathBuf::display parses as a syn::Path")
                } else {
                    syn::parse_str("std::convert::identity")
                        .expect("std::convert::identity parses as a syn::Path")
                }
            });
        let ignore = lookup
            .remove(&KnownAttribute::ignore)
            .map(WithSpan::into_inner)
            .map(|parsed| match parsed {
                ParseAttribute::ignore(inner) => inner,
                _ => unreachable!(),
            });
        crate::shared::check_empty(lookup)?;

        Ok(ParseField {
            ident,
            name,
            ignore,
            display,
        })
    }
}



```

Each attribute we support is queried. If it doesn't exist, we set a default and keep going until all information needed to build the struct is present. If we parse an attribute into the lookup but forget to remove it, an exception is raised that points to the attribute that we forgot to wire up.

It might seem like we added a lot of code, but most of this boils down to:

- Define all valid attributes in a `ParseAttribute` enum with a `KnownAttribute` discriminant
- Implement `syn::parse::Parse` for these enums
- Implement a function that takes in a `&[syn::Attribute]` and returns `HashMap` that allows us to pull out the `ParseAttribute`
- Add any new fields needed to your `ParseField` struct
- Adjust your building functions to use the new attribute information collected.

Sometimes, it's easier to go the other direction. You can define the fields you need for `ParseField` and then figure out the API you want to make to support it, but from a testing perspective, it's easier to start with smaller parsers and gradually combine them to build bigger ones.

We're done with the field modifications but haven't implemented the logic in our primary derive function yet. We will do that shortly. We also haven't added a test for this new syntax. Previously we used integration tests in the form of doctests, however I want the ability to assert failing behavior, such as an attribute that's defined twice, and I want to assert that we're pointing at the spans we expect. To do that, we will add the [`try_build`](https://crates.io/crates/trybuild) crate, which can help us visualize compiler errors that our users will see.

```
$ cargo add --dev trybuild@1.0.104 --package cache_diff
    Updating crates.io index
      Adding trybuild v1.0.104 to dev-dependencies
             Features:
             - diff
    Updating crates.io index
     Locking 29 packages to latest compatible versions
      Adding equivalent v1.0.2
      Adding glob v0.3.2
      Adding hashbrown v0.15.2
      Adding indexmap v2.8.0
      Adding itoa v1.0.15
      Adding memchr v2.7.4
      Adding ryu v1.0.20
      Adding serde v1.0.219
      Adding serde_derive v1.0.219
      Adding serde_json v1.0.140
      Adding serde_spanned v0.6.8
      Adding target-triple v0.1.4
      Adding termcolor v1.4.1
      Adding toml v0.8.20
      Adding toml_datetime v0.6.8
      Adding toml_edit v0.22.24
      Adding trybuild v1.0.104
      Adding winapi-util v0.1.9
      Adding windows-sys v0.59.0
      Adding windows-targets v0.52.6
      Adding windows_aarch64_gnullvm v0.52.6
      Adding windows_aarch64_msvc v0.52.6
      Adding windows_i686_gnu v0.52.6
      Adding windows_i686_gnullvm v0.52.6
      Adding windows_i686_msvc v0.52.6
      Adding windows_x86_64_gnu v0.52.6
      Adding windows_x86_64_gnullvm v0.52.6
      Adding windows_x86_64_msvc v0.52.6
      Adding winnow v0.7.4
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Now use this library to assert that all fixtures in `test/fails` fail to compile and `tests/pass` successfully compile.

In file `cache_diff/tests/compilation_tests.rs` write:

```rust
#[test]
fn should_not_compile() {
    let t = trybuild::TestCases::new();
    t.compile_fail("tests/fails/*.rs");
}

#[test]
fn should_compile() {
    let t = trybuild::TestCases::new();
    t.pass("tests/pass/*.rs");
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Now add a compilation failure case.

In file `cache_diff/tests/fails/duplicate_attribute.rs` write:

```
use cache_diff::CacheDiff;

#[derive(CacheDiff)]
struct CustomDiffFn {
    #[cache_diff(rename = "foo", rename = "bar")]
    name: String,
}

fn main() {}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

And assert the output of that failure case:

```
$ cat cache_diff/tests/fails/duplicate_attribute.stderr
error: CacheDiff duplicate attribute: `rename`
 --> tests/fails/duplicate_attribute.rs:5:34
  |
5 |     #[cache_diff(rename = "foo", rename = "bar")]
  |                                  ^^^^^^

error: previously `rename` defined here
 --> tests/fails/duplicate_attribute.rs:5:18
  |
5 |     #[cache_diff(rename = "foo", rename = "bar")]
  |                  ^^^^^^
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Verify tests are all passing:

```
$ cargo test
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

If your project is failing or if the tests you added didn't run, here's the full project for reference:

<details>
  <summary>Full project</summary>

```
$ exa --tree --git-ignore .
.
├── cache_diff
│  ├── Cargo.toml
│  ├── src
│  │  └── lib.rs
│  └── tests
│     ├── compilation_tests.rs
│     └── fails
│        ├── duplicate_attribute.rs
│        └── duplicate_attribute.stderr
├── cache_diff_derive
│  ├── Cargo.toml
│  └── src
│     ├── lib.rs
│     ├── parse_container.rs
│     ├── parse_field.rs
│     └── shared.rs
├── Cargo.lock
└── Cargo.toml
$ cat Cargo.toml
[workspace]
members = [
    "cache_diff",
    "cache_diff_derive"
]
resolver = "2"
$ cat cache_diff/Cargo.toml
[package]
name = "cache_diff"
version = "0.1.0"
edition = "2024"

[dependencies]
cache_diff_derive = { version = "0.1.0" , optional = true, path = "../cache_diff_derive" }

[features]
derive = ["dep:cache_diff_derive"]
default = ["derive"]

[dev-dependencies]
trybuild = "1.0.104"
$ cat cache_diff_derive/Cargo.toml
[package]
name = "cache_diff_derive"
version = "0.1.0"
edition = "2024"

[dependencies]
# Turn Rust code into Tokens
quote = "1.0.37"
# Parse tokens into Rust code
syn = { version = "2.0.83", features = ["extra-traits"] }
proc-macro2 = "1.0.89"
strum = { version = "0.27.1", features = ["derive"] }
[lib]
proc-macro = true
$ cat cache_diff/src/lib.rs
// File: `cache_diff/src/lib.rs`
//! Cache Diff (derive)
//!
//! Generate the difference between two structs for the purposes of cache invalidation.
//!
//! Example:
//!
//! ```
//! use cache_diff::CacheDiff;
//!
//! #[derive(CacheDiff, Debug)]
//! struct Metadata {
//!     ruby_version: String,
//!     architecture: String,
//! }
//!
//! let diff = Metadata {ruby_version: "3.4.2".to_string(), architecture: "arm64".to_string()}
//!     .diff(&Metadata {ruby_version: "3.3.1".to_string(), architecture: "amd64".to_string()});
//!
//! assert_eq!(
//!     vec!["ruby version (3.3.1 to 3.4.2)".to_string(), "architecture (amd64 to arm64)".to_string()],
//!     diff
//! );
//! ```
#[cfg(feature = "derive")]
pub use cache_diff_derive::CacheDiff;
// Code
pub trait CacheDiff {
    fn diff(&self, old: &Self) -> Vec<String>;
}

#[cfg(test)]
mod tests {
    // Test use
    use super::*;
    // Test code
    struct Metadata {
        ruby_version: String,
        architecture: String,
    }

    impl CacheDiff for Metadata {
        fn diff(&self, old: &Self) -> Vec<String> {
            let mut diff = Vec::new();

            if self.ruby_version != old.ruby_version {
                diff.push(format!("ruby version ({} to {})",
                old.ruby_version,
                self.ruby_version))
            }
            if self.architecture != old.architecture {
                diff.push(
                    format!("architecture ({} to {})",
                    old.architecture,
                    self.architecture)
                )
            }
            diff
        }
    }

    #[test]
    fn test_changed_metadata() {
        let old = Metadata {
            ruby_version: "3.3.1".to_string(),
            architecture: "amd64".to_string()
        };
        let new = Metadata {
            ruby_version: "3.4.2".to_string(),
            architecture: "arm64".to_string()
        };

        assert_eq!(
            vec![
                "ruby version (3.3.1 to 3.4.2)".to_string(),
                "architecture (amd64 to arm64)".to_string()
            ],
            new.diff(&old)
        );
    }

    #[test]
    fn test_unchanged_metadata() {
        let old = Metadata {
            ruby_version: "3.1.4".to_string(),
            architecture: "amd64".to_string()
        };

        let diff = old.diff(&old);
        assert!(
            diff.is_empty(),
            "Expected diff to be empty but is {:?}",
            diff
        );
    }
}
$ cat cache_diff_derive/src/lib.rs
// File: `cache_diff_derive/src/lib.rs`
mod parse_field;
mod parse_container;
mod shared;
use proc_macro::TokenStream;
use parse_container::ParseContainer;
use parse_field::ParseField;
// Code
pub(crate) const NAMESPACE: &str = "cache_diff";
pub(crate) const MACRO_NAME: &str = "CacheDiff";

#[proc_macro_derive(CacheDiff, attributes(cache_diff))]
pub fn cache_diff(item: TokenStream)
    -> TokenStream {
    create_cache_diff(item.into())
        .unwrap_or_else(syn::Error::into_compile_error)
        .into()
}

fn create_cache_diff(item: proc_macro2::TokenStream)
    -> syn::Result<proc_macro2::TokenStream> {
    let derive_input: syn::DeriveInput = syn::parse2(item)?;
    let container = ParseContainer::from_derive_input(&derive_input)?;
    let ident = &container.ident;
    let generics = &container.generics;

    let mut comparisons = Vec::new();
    for field in container.fields.iter() {
        let ParseField {
            ident,
            name,
            ..
        } = field;

        comparisons.push(quote::quote! {
            if self.#ident != old.#ident {
                differences.push(
                    format!("{name} ({old} to {new})",
                        name = #name,
                        old = &old.#ident,
                        new = &self.#ident,
                    )
                );
            }
        });
    }
    let (impl_generics, type_generics, where_clause) = generics.split_for_impl();
    Ok(quote::quote! {
        impl #impl_generics ::cache_diff::CacheDiff for #ident #type_generics #where_clause {
            fn diff(&self, old: &Self) -> ::std::vec::Vec<String> {
                let mut differences = ::std::vec::Vec::new();
                #(#comparisons)*
                differences
            }
        }
    })
}
$ cat cache_diff_derive/src/parse_field.rs
// File: `cache_diff_derive/src/parse_field.rs`
use crate::MACRO_NAME;
use syn::spanned::Spanned;
use std::str::FromStr;
use strum::IntoEnumIterator;
use crate::shared::WithSpan;
// Code
/// Field (i.e. `name: String`) of a container (struct) and its parsed attributes
/// i.e. `#[cache_diff(rename = "Ruby version")]`
#[derive(Debug)]
pub(crate) struct ParseField {
    /// The proc-macro identifier for a field i.e. `name: String` would be a programmatic
    /// reference to `name` that can be used along with `quote!` to produce code.
    pub(crate) ident: syn::Ident,
    /// What the user will see when this field differs and invalidates the cache
    /// i.e. `age: usize` will be `"age"`.
    pub(crate) name: String,
    /// Whether or not the field is included in the derived diff comparison
    pub(crate) ignore: Option<String>,
    /// The function to use when rendering values on the field
    /// i.e. `age: 42` will be `"42"`
    pub(crate) display: syn::Path,
}

impl ParseField {
    pub(crate) fn from_field(field: &syn::Field) -> Result<Self, syn::Error> {
        let ident = field.ident.clone().ok_or_else(|| {
            syn::Error::new(
                field.span(),
                format!("{MACRO_NAME} can only be used on structs with named fields"),
            )
        })?;

        let mut lookup = crate::shared::attribute_lookup::<ParseAttribute>(&field.attrs)?;
        let name = lookup
            .remove(&KnownAttribute::rename)
            .map(WithSpan::into_inner)
            .map(|parsed| match parsed {
                ParseAttribute::rename(inner) => inner,
                _ => unreachable!(),
            })
            .unwrap_or_else(|| ident.to_string().replace("_", " "));
        let display = lookup
            .remove(&KnownAttribute::display)
            .map(WithSpan::into_inner)
            .map(|parsed| match parsed {
                ParseAttribute::display(inner) => inner,
                _ => unreachable!(),
            })
            .unwrap_or_else(|| {
                if is_pathbuf(&field.ty) {
                    syn::parse_str("std::path::Path::display")
                        .expect("PathBuf::display parses as a syn::Path")
                } else {
                    syn::parse_str("std::convert::identity")
                        .expect("std::convert::identity parses as a syn::Path")
                }
            });
        let ignore = lookup
            .remove(&KnownAttribute::ignore)
            .map(WithSpan::into_inner)
            .map(|parsed| match parsed {
                ParseAttribute::ignore(inner) => inner,
                _ => unreachable!(),
            });
        crate::shared::check_empty(lookup)?;

        Ok(ParseField {
            ident,
            name,
            ignore,
            display,
        })
    }
}


/// A single attribute
#[derive(strum::EnumDiscriminants, Debug, PartialEq)]
#[strum_discriminants(
    name(KnownAttribute),
    derive(strum::EnumIter, strum::Display, strum::EnumString, Hash)
)]
enum ParseAttribute {
    #[allow(non_camel_case_types)]
    rename(String), // #[cache_diff(rename="...")]
    #[allow(non_camel_case_types)]
    display(syn::Path), // #[cache_diff(display=<function>)]
    #[allow(non_camel_case_types)]
    ignore(String), // #[cache_diff(ignore)]
}

impl syn::parse::Parse for KnownAttribute {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let identity = input.parse::<syn::Ident>()?;
        crate::shared::known_attribute(&identity)
    }
}

impl syn::parse::Parse for ParseAttribute {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let key: KnownAttribute = input.parse()?;

        match key {
            KnownAttribute::rename => {
                input.parse::<syn::Token![=]>()?;
                Ok(ParseAttribute::rename(
                    input.parse::<syn::LitStr>()?.value(),
                ))
            }
            KnownAttribute::display => {
                input.parse::<syn::Token![=]>()?;
                Ok(ParseAttribute::display(input.parse()?))
            }
            KnownAttribute::ignore => {
                if input.peek(syn::Token![=]) {
                    input.parse::<syn::Token![=]>()?;
                    Ok(ParseAttribute::ignore(
                        input.parse::<syn::LitStr>()?.value(),
                    ))
                } else {
                    Ok(ParseAttribute::ignore("default".to_string()))
                }
            }
        }
    }
}

fn is_pathbuf(ty: &syn::Type) -> bool {
    if let syn::Type::Path(type_path) = ty {
        if let Some(segment) = type_path.path.segments.last() {
            return segment.ident == "PathBuf" && segment.arguments == syn::PathArguments::None;
        }
    }
    false
}

#[cfg(test)]
mod tests {
    // Test use
    use super::*;
    // Test code
    #[test]
    fn test_parse_field_plain() {
        let field: syn::Field = syn::parse_quote! {
            ruby_version: String
        };

        let parsed = ParseField::from_field(&field).unwrap();
        assert_eq!("ruby version".to_string(), parsed.name);
    }

    #[test]
    fn test_requires_named_struct() {
        let field: syn::Field = syn::parse_quote! {()};

        let result = ParseField::from_field(&field);
        assert!(result.is_err(), "Expected an error, got {:?}", result);
        assert_eq!(
            format!("{}", result.err().unwrap()),
            r#"CacheDiff can only be used on structs with named fields"#
        );
    }

    #[test]
    fn test_known_attributes() {
        let parsed: KnownAttribute = syn::parse_str("rename").unwrap();
        assert_eq!(KnownAttribute::rename, parsed);

        let parsed: KnownAttribute = syn::parse_str("ignore").unwrap();
        assert_eq!(KnownAttribute::ignore, parsed);

        let parsed: KnownAttribute = syn::parse_str("display").unwrap();
        assert_eq!(KnownAttribute::display, parsed);

        let result: Result<KnownAttribute, syn::Error> = syn::parse_str("unknown");
        assert!(result.is_err(), "Expected an error, got {:?}", result);
        assert_eq!(
            format!("{}", result.err().unwrap()),
            r#"Unknown cache_diff attribute: `unknown`. Must be one of `rename`, `display`, `ignore`"#
        );
    }

    #[test]
    fn test_parse_attributes() {
        let parsed: ParseAttribute = syn::parse_str(r#"rename = "Ruby version""#).unwrap();
        assert_eq!(ParseAttribute::rename("Ruby version".to_string()), parsed);

        let parsed: ParseAttribute = syn::parse_str(r#"display= my_function"#).unwrap();
        assert!(matches!(parsed, ParseAttribute::display(_))); let parsed: ParseAttribute = syn::parse_str(r#"ignore = "i have my reasons""#).unwrap();
        assert!(matches!(parsed, ParseAttribute::ignore(_)));

        let parsed: ParseAttribute = syn::parse_str("ignore").unwrap();
        assert!(matches!(parsed, ParseAttribute::ignore(_)));
    }
}
$ cat cache_diff_derive/src/parse_container.rs
// File: `cache_diff_derive/src/parse_container.rs`
use crate::parse_field::ParseField;
use crate::MACRO_NAME;
// Code
/// Container (i.e. struct Metadata { ... }) and its parsed attributes
/// i.e. `#[cache_diff( ... )]`
#[derive(Debug)]
pub(crate) struct ParseContainer {
    /// The proc-macro identifier for a container i.e. `struct Metadata { }` would be a programmatic
    /// reference to `Metadata` that can be used along with `quote!` to produce code.
    pub(crate) ident: syn::Ident,
    /// Info about generics, lifetimes and where clauses i.e. `struct Metadata<T> { name: T }`
    pub(crate) generics: syn::Generics,
    /// Fields (i.e. `name: String`) and their associated attributes i.e. `#[cache_diff(...)]`
    pub(crate) fields: Vec<ParseField>,
}

impl ParseContainer {
    pub(crate) fn from_derive_input(input: &syn::DeriveInput) -> Result<Self, syn::Error> {
        let ident = input.ident.clone();
        let generics = input.generics.clone();
        let fields = match input.data {
            syn::Data::Struct(syn::DataStruct {
                fields: syn::Fields::Named(syn::FieldsNamed { ref named, .. }),
                ..
            }) => named,
            _ => {
                return Err(syn::Error::new(
                    ident.span(),
                    format!("{MACRO_NAME} can only be used on named structs"),
                ))
            }
        }
        .into_iter()
        .map(ParseField::from_field)
        .collect::<Result<Vec<ParseField>, syn::Error>>()?;

        Ok(ParseContainer { ident, generics, fields })
    }
}

#[cfg(test)]
mod tests {
    // Test use
    use super::*;
    // Test code
    #[test]
    fn test_parses() {
        let container = ParseContainer::from_derive_input(&syn::parse_quote! {
            struct Metadata {
                version: String
            }
        })
        .unwrap();
        assert_eq!(1, container.fields.len());

        let container = ParseContainer::from_derive_input(&syn::parse_quote! {
            struct Metadata {
                version: String,
                checksum: String
            }
        })
        .unwrap();
        assert_eq!(2, container.fields.len());
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->
</details>

We need to adjust our container code to add a container attribute, and then our final `lib.rs` code needs to use all this tasty info we just added.

<span id="chapter_08" />

## 08: Add attributes to ParseContainer

We'll define an enum to hold each container attribute variant as we did with fields. Add this code:

```rust

// File: `cache_diff_derive/src/parse_container.rs`
// Use ...
use std::str::FromStr;
use strum::IntoEnumIterator;
// Code
// ...
/// A single attribute
#[derive(strum::EnumDiscriminants, Debug, PartialEq)]
#[strum_discriminants(
    name(KnownAttribute),
    derive(strum::EnumIter, strum::Display, strum::EnumString, Hash)
)]
enum ParseAttribute {
    #[allow(non_camel_case_types)]
    custom(syn::Path), // #[cache_diff(custom=<function>)]
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

We will go ahead and add an implementation of `syn::parse::Parse` for `KnownAttribute`, it's virtually identical:

```rust
// File: `cache_diff_derive/src/parse_container.rs`
// Use ...
use crate::NAMESPACE;
// Code
// ...
impl syn::parse::Parse for KnownAttribute {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let identity: syn::Ident = input.parse()?;
        crate::shared::known_attribute(&identity)
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Now, implement the parsing logic. Add this code:

```rust
// File: `cache_diff_derive/src/parse_container.rs`
// Use ...

// Code
// ...
impl syn::parse::Parse for ParseAttribute {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let key: KnownAttribute = input.parse()?;
        input.parse::<syn::Token![=]>()?;
        match key {
            KnownAttribute::custom => Ok(ParseAttribute::custom(input.parse()?)),
        }
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Verify your intuition (and my claims) with some tests. Add this test code:

```rust
// File: `cache_diff_derive/src/parse_container.rs`
// Use ...

// Code
// ...

#[cfg(test)]
mod tests {
    // Test use
    // ...

    // Test code
    // ...
    #[test]
    fn test_known_attributes() {
        let attribute: KnownAttribute = syn::parse_str("custom").unwrap();
        assert_eq!(KnownAttribute::custom, attribute);
    }

    #[test]
    fn test_parse_attribute() {
        let attribute: ParseAttribute = syn::parse_str("custom = my_function").unwrap();
        assert!(matches!(attribute, ParseAttribute::custom(_)));

        let result: Result<ParseAttribute, syn::Error> = syn::parse_str("unknown");
        assert!(result.is_err(), "Expected an error, got {:?}", result);
        assert_eq!(
            r"Unknown cache_diff attribute: `unknown`. Must be one of `custom`",
            format!("{}", result.err().unwrap()),
        );
    }

    #[test]
    fn test_custom_parse_attribute() {
        let input: syn::DeriveInput = syn::parse_quote! {
            #[cache_diff(custom = my_function)]
            struct Metadata {
                name: String
            }
        };

        assert!(matches!(
            crate::shared::attribute_lookup::<ParseAttribute>(&input.attrs)
                .unwrap()
                .remove(&KnownAttribute::custom)
                .unwrap()
                .into_inner(),
            ParseAttribute::custom(_)
        ));
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Verify they work:

```
$ cargo test
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Now, we can parse attributes for containers. Let's add that information to our container struct. Replace this code:

```rust
// File: `cache_diff_derive/src/parse_container.rs`
// Use ...

// Code
// ...
/// Container (i.e. struct Metadata { ... }) and its parsed attributes
/// i.e. `#[cache_diff( ... )]`
#[derive(Debug)]
pub(crate) struct ParseContainer {
    /// The proc-macro identifier for a container i.e. `struct Metadata { }` would be a programmatic
    /// reference to `Metadata` that can be used along with `quote!` to produce code.
    pub(crate) ident: syn::Ident,
    /// Info about generics, lifetimes and where clauses i.e. `struct Metadata<T> { name: T }`
    pub(crate) generics: syn::Generics,
    /// Fields (i.e. `name: String`) and their associated attributes i.e. `#[cache_diff(...)]`
    pub(crate) fields: Vec<ParseField>,
}


```

With with these new contents:


```rust
// File: `cache_diff_derive/src/parse_container.rs`
// Use ...

// Code
// ...
/// Container (i.e. struct Metadata { ... }) and its parsed attributes
/// i.e. `#[cache_diff( ... )]`
#[derive(Debug)]
pub(crate) struct ParseContainer {
    /// The proc-macro identifier for a container i.e. `struct Metadata { }` would be a programmatic
    /// reference to `Metadata` that can be used along with `quote!` to produce code.
    pub(crate) ident: syn::Ident,
    /// Info about generics, lifetimes and where clauses i.e. `struct Metadata<T> { name: T }`
    pub(crate) generics: syn::Generics,
    /// An optional path to a custom diff function
    /// Set via attribute on the container i.e. `#[cache_diff(custom = <function>)]`
    pub(crate) custom: Option<syn::Path>,
    /// Fields (i.e. `name: String`) and their associated attributes i.e. `#[cache_diff(...)]`
    pub(crate) fields: Vec<ParseField>,
}


```

Import the helper struct:

```rust
// File: `cache_diff_derive/src/parse_container.rs`
// Use ...
use crate::shared::WithSpan;
// Code
// ...
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Now, update the logic for building the container. Replace this code:

```rust
// File: `cache_diff_derive/src/parse_container.rs`
// Use ...

// Code
// ...
impl ParseContainer {
    pub(crate) fn from_derive_input(input: &syn::DeriveInput) -> Result<Self, syn::Error> {
        let ident = input.ident.clone();
        let generics = input.generics.clone();
        let fields = match input.data {
            syn::Data::Struct(syn::DataStruct {
                fields: syn::Fields::Named(syn::FieldsNamed { ref named, .. }),
                ..
            }) => named,
            _ => {
                return Err(syn::Error::new(
                    ident.span(),
                    format!("{MACRO_NAME} can only be used on named structs"),
                ))
            }
        }
        .into_iter()
        .map(ParseField::from_field)
        .collect::<Result<Vec<ParseField>, syn::Error>>()?;

        Ok(ParseContainer { ident, generics, fields })
    }
}


```

With with these new contents:


```rust
// File: `cache_diff_derive/src/parse_container.rs`
// Use ...

// Code
// ...
impl ParseContainer {
    pub(crate) fn from_derive_input(input: &syn::DeriveInput) -> Result<Self, syn::Error> {
        let ident = input.ident.clone();
        let generics = input.generics.clone();
        let mut lookup = crate::shared::attribute_lookup::<ParseAttribute>(&input.attrs)?;
        let custom = lookup
            .remove(&KnownAttribute::custom)
            .map(WithSpan::into_inner)
            .map(|parsed| match parsed {
                ParseAttribute::custom(path) => path,
            });

        let fields = match input.data {
            syn::Data::Struct(syn::DataStruct {
                fields: syn::Fields::Named(syn::FieldsNamed { ref named, .. }),
                ..
            }) => named,
            _ => {
                return Err(syn::Error::new(
                    ident.span(),
                    format!("{MACRO_NAME} can only be used on named structs"),
                ))
            }
        }
        .into_iter()
        .map(ParseField::from_field)
        .collect::<Result<Vec<ParseField>, syn::Error>>()?;

        crate::shared::check_empty(lookup)?;

        if let Some(field) = fields
            .iter()
            .find(|field| matches!(field.ignore.as_deref(), Some("custom")))
        {
            if custom.is_none() {
                let mut error = syn::Error::new(
                    proc_macro2::Span::call_site(),
                    format!("`Expected `{ident}` to implement the `custom` attribute `#[{NAMESPACE}(custom = <function>)]`, but it does not"),
                );
                error.combine(syn::Error::new(
                    field.ident.span(),
                    format!(
                        "Field `{}` is ignored and requires `{ident}` to implement `custom`",
                        field.ident
                    ),
                ));
                return Err(error);
            }
        }

        if fields.iter().any(|f| f.ignore.is_none()) {
            Ok(ParseContainer {
                ident,
                generics,
                fields,
                custom,
            })
        } else {
            Err(syn::Error::new(ident.span(), format!("No fields to compare for {MACRO_NAME}, ensure struct has at least one named field that isn't `{NAMESPACE}(ignore)`")))
        }
    }
}


```

There are two new things here; one of them is small and expected. We lookup the custom attribute from our `HashMap` similar to what we did with `ParseField`:



, I hope you were expecting that addition. The other is A bunch of error handling. For example:



Previously, when I added the ability to set a field as ignored with a reason, it allowed us to add a preference signal that did something meaningful. In this case, we are saying that if the user adds a `#[cache_diff(ignore = "custom")]` to one of their fields, they MUST also add a `#[cache_diff(custom = <function>)]` to the container. Because proc macros make it faster for the end user to generate and manipulate code, it makes it faster for them to make mistakes, too. You could imagine a scenario where they're playing around with configuration options, and they accidentally delete the container attribute line, and it's not caught in code review, and the linter isn't loud enough, so they deploy with code that looks correct but isn't.

The nice thing about adding this error here is that when the user tries to compile their code with an invalid state, it's not representable, and they get a clear error explaining what went wrong and how to fix it. Coming from (such a flexible and dynamic language as) Ruby, these defensive coding practices are second nature to me. [A talk by Avdii back from 2011 comes to mind as having some good examples](https://www.youtube.com/watch?v=t8s2MqnDPD8). You don't need to pre-think every possible thing a coder can do wrong with your library, but it's worth spending a moment or two thinking of failure modes ahead of your first proc-macro release. Once you've released your macro, be on the lookout for examples of incorrect usage from other devs and from your code and notes.

The other error is here:



I don't want the derived code to compile if someone tries to use the macro on an empty struct or accidentally ignores all the fields. If someone has a legitimate use for a type that is `impl CacheDiff` but always returns an empty difference set, that's fine...but I won't help them construct such an abomination. I'm not blocking them from implementing it manually; I'm only blocking it via a derive macro. Whenever I write reflection code, I like to have a strong sense of what code paths should be encouraged, which should be allowable but discouraged, and which should be impossible. I also believe that many programmers have more smarts than empathy, and thanks to Turing completeness, that means statements like "I cannot imagine a reason why anyone would want to X" may be due to a lack of imagination rather than a lack of a good reason for doing that thing.

I consider the error experience, how our interfaces behave in failure scenarios, to be a true test of quality software design. Even better design, allows us to assert those failure scenarios via tests. Add the testing code now:

```rust
// File: `cache_diff_derive/src/parse_container.rs`
// Use ...

// Code
// ...

#[cfg(test)]
mod tests {
    // Test use
    // ...

    // Test code
    // ...
    #[test]
    fn test_no_fields() {
        let result = ParseContainer::from_derive_input(&syn::parse_quote! {
            struct Metadata { }
        });
        assert!(result.is_err(), "Expected an error, got {:?}", result);
        assert_eq!(
            format!("{}", result.err().unwrap()),
            r#"No fields to compare for CacheDiff, ensure struct has at least one named field that isn't `cache_diff(ignore)`"#
        );
    }

    #[test]
    fn test_all_ignored() {
        let result = ParseContainer::from_derive_input(&syn::parse_quote! {
            struct Metadata {
                #[cache_diff(ignore)]
                version: String
            }
        });
        assert!(result.is_err(), "Expected an error, got {:?}", result);
        assert_eq!(
            format!("{}", result.err().unwrap()),
            r#"No fields to compare for CacheDiff, ensure struct has at least one named field that isn't `cache_diff(ignore)`"#
        );
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

With all this in place, it's time to Derive to the finish line. The following section will use our newly defined field and container attributes in the proc macro output.

<span id="chapter_09" />

## 09: Implement the All-Wheel Derive Macro (customizable with attributes)

With the parsing logic contained within `ParseContainer` and `ParseField`, we can focus on implementing the core logic of our macro. Replace this code:

```rust
// File: `cache_diff_derive/src/lib.rs`
// Mod ...

// Use ...

// Code
// ...
fn create_cache_diff(item: proc_macro2::TokenStream)
    -> syn::Result<proc_macro2::TokenStream> {
    let derive_input: syn::DeriveInput = syn::parse2(item)?;
    let container = ParseContainer::from_derive_input(&derive_input)?;
    let ident = &container.ident;
    let generics = &container.generics;

    let mut comparisons = Vec::new();
    for field in container.fields.iter() {
        let ParseField {
            ident,
            name,
            ..
        } = field;

        comparisons.push(quote::quote! {
            if self.#ident != old.#ident {
                differences.push(
                    format!("{name} ({old} to {new})",
                        name = #name,
                        old = &old.#ident,
                        new = &self.#ident,
                    )
                );
            }
        });
    }
    let (impl_generics, type_generics, where_clause) = generics.split_for_impl();
    Ok(quote::quote! {
        impl #impl_generics ::cache_diff::CacheDiff for #ident #type_generics #where_clause {
            fn diff(&self, old: &Self) -> ::std::vec::Vec<String> {
                let mut differences = ::std::vec::Vec::new();
                #(#comparisons)*
                differences
            }
        }
    })
}


```

With with these new contents:


```rust
// File: `cache_diff_derive/src/lib.rs`
// Mod ...

// Use ...

// Code
// ...
fn create_cache_diff(item: proc_macro2::TokenStream) -> syn::Result<proc_macro2::TokenStream> {
    let ParseContainer {
        ident,
        generics,
        custom,
        fields,
    } = ParseContainer::from_derive_input(&syn::parse2(item)?)?;

    let custom_diff = if let Some(ref custom_fn) = custom {
        quote::quote! {
            let custom_diff = #custom_fn(old, self);
            for diff in &custom_diff {
                differences.push(diff.to_string())
            }
        }
    } else {
        quote::quote! {}
    };

    let mut comparisons = Vec::new();
    for field in fields.iter() {
        let ParseField {
            ident,
            name,
            ignore,
            display,
        } = field;

        if ignore.is_none() {
            comparisons.push(quote::quote! {
                if self.#ident != old.#ident {
                    differences.push(
                        format!("{name} ({old} to {new})",
                            name = #name,
                            old = #display(&old.#ident),
                            new = #display(&self.#ident)
                        )
                    );
                }
            });
        }
    }
    let (impl_generics, type_generics, where_clause) = generics.split_for_impl();
    Ok(quote::quote! {
        impl #impl_generics ::cache_diff::CacheDiff for #ident #type_generics #where_clause {
            fn diff(&self, old: &Self) -> ::std::vec::Vec<String> {
                let mut differences = ::std::vec::Vec::new();
                #custom_diff
                #(#comparisons)*
                differences
            }
        }
    })
}


```

One thing to call out here is that I'm using `::std::vec::Vec<String>`. The beginning `::` is because the environment where the generated code will live is not hygienic." The [rust reference](https://doc.rust-lang.org/reference/procedural-macros.html#procedural-macro-hygiene) says more. But basically, if you used `Vec`, then the calling code could change the behavior of your output by accident if they `use some_other_thing as Vec`. So, to avoid ambiguity, we use full paths and start them with `::` (otherwise, someone could `use other_thing as std`).

The logic inside of the function is similar to what we saw before. Pull out values from the parsed token stream using `syn`. Use those values to generate rust code with `quote`. Like before, we will write doctests that use our features like a user would. Beyond convincing you that the code we wrote works, this documentation will be easy to find for anyone using the macro.

I like to make one example per (major) feature. And use something close to the real-world reason why I added the feature. In my [book on contributing to open source](http://howtoopensource.dev/), there is a  documentation chapter where we document code someone else wrote, I stressed that documentation should help answer the question "why does this (feature) exist." Great documentation doesn't just say why the code exists. It shows it.

Add docs for `ignore` now:

```rust
// File: `cache_diff/src/lib.rs`
// Module docs ...
//! ## Ignore attributes
//!
//! If the struct contains fields that should not be included in the diff comparison, you can ignore them:
//!
//! ```rust
//! use cache_diff::CacheDiff;
//!
//! #[derive(CacheDiff)]
//! struct Metadata {
//!     version: String,
//!
//!     #[cache_diff(ignore)]
//!     changed_by: String
//! }
//! let now = Metadata { version: "3.4.0".to_string(), changed_by: "Alice".to_string() };
//! let diff = now.diff(&Metadata { version: now.version.clone(), changed_by: "Bob".to_string() });
//!
//! assert!(diff.is_empty());
//! ```
// Use ...

// Code
// ...
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Add rename docs:

```rust
// File: `cache_diff/src/lib.rs`
// Module docs ...
//! ## Rename attributes
//!
//! If your field name is not descriptive enough, you can rename it:
//!
//! ```rust
//! use cache_diff::CacheDiff;
//!
//! #[derive(CacheDiff)]
//! struct Metadata {
//!     #[cache_diff(rename="Ruby version")]
//!     version: String,
//! }
//! let now = Metadata { version: "3.4.0".to_string() };
//! let diff = now.diff(&Metadata { version: "3.3.0".to_string() });
//!
//! assert_eq!("Ruby version (3.3.0 to 3.4.0)", diff.join(" "));
//! ```
//!
// Use ...

// Code
// ...
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Add display docs:

```rust
// File: `cache_diff/src/lib.rs`
// Module docs ...
//! ## Handle structs missing display
//!
//! Not all structs implement the [`Display`](std::fmt::Display) trait, for example [`std::path::PathBuf`](std::path::PathBuf) requires that you call `display()` on it.
//!
//! The `#[derive(CacheDiff)]` macro will automatically handle the following conversions for you:
//!
//! - `std::path::PathBuf` (via [`std::path::Path::display`](std::path::Path::display))
//!
//! However, if you have a custom struct that does not implement [`Display`](std::fmt::Display), you can specify a function to call instead:
//!
//! ```rust
//! use cache_diff::CacheDiff;
//!
//! #[derive(CacheDiff)]
//! struct Metadata {
//!     #[cache_diff(display = my_function)]
//!     version: NoDisplay,
//! }
//!
//! #[derive(PartialEq)]
//! struct NoDisplay(String);
//! fn my_function(s: &NoDisplay) -> String {
//!     format!("custom {}", s.0)
//! }
//!
//! let now = Metadata { version: NoDisplay("3.4.0".to_string())};
//! let diff = now.diff(&Metadata { version: NoDisplay("3.3.0".to_string())});
//!
//! assert_eq!("version (custom 3.3.0 to custom 3.4.0)", diff.join(" "));
//! ```
//!
// Use ...

// Code
// ...
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Add custom function docs:

```rust
// File: `cache_diff/src/lib.rs`
// Module docs ...
//! ## Customize one or more field differences
//!
//! You can provide a custom implementation for a diffing a subset of fields without having to roll your own implementation.
//!
//! ### Custom logic for one field example
//!
//! Here's an example where someone wants to bust the cache after N cache calls. Everything else other than `cache_usage_count` can be derived. If you want to keep the existing derived difference checks, but add on a custom one you can do it like this:
//!
//! ```rust
//! use cache_diff::CacheDiff;
//! const MAX: f32 = 200.0;
//!
//! #[derive(Debug, CacheDiff)]
//! #[cache_diff(custom = diff_cache_usage_count)]
//! pub(crate) struct Metadata {
//!     #[cache_diff(ignore = "custom")]
//!     cache_usage_count: f32,
//!
//!     binary_version: String,
//!     target_arch: String,
//!     os_distribution: String,
//!     os_version: String,
//! }
//!
//! fn diff_cache_usage_count(_old: &Metadata, now: &Metadata) -> Vec<String> {
//!     let Metadata {
//!         cache_usage_count,
//!         binary_version: _,
//!         target_arch: _,
//!         os_distribution: _,
//!         os_version: _,
//!     } = now;
//!
//!     if cache_usage_count > &MAX {
//!         vec![format!("Cache count ({}) exceeded limit {MAX}", cache_usage_count)]
//!     } else {
//!         Vec::new()
//!     }
//! }
//! ```
//!
//! In this example, four fields are derived automatically, saving us time, while one field is custom
//! using the `#[cache_diff(custom = diff_cache_usage_count)]` attribute on the struct. This tells
//! [CacheDiff] to call this function and pass in the old and current values. It expects a vector
//! with some strings if there is a difference and an empty vector if there are none.
//!
//! Don't forget to `#[cache_diff(ignore = "custom")]` any fields you're implementing yourself. You can also use this feature to
//! combine several fields into a single diff output, for example, using the previous struct, if
//! you only wanted to have one output for a combined `os_distribution` and `os_version` in one output
//! like "OS (ubuntu-22 to ubuntu-24)". Alternatively, you can use <https://github.com/schneems/magic_migrate> to
//! re-arrange your struct to only have one field with a custom display.
//!
// Use ...

// Code
// ...
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

And make sure it works as expected:

```
$ cargo clippy
    Checking unicode-ident v1.0.18
    Checking strum v0.27.1
   Compiling cache_diff_derive v0.1.0 (/private/var/folders/yr/yytf3z3n3q336f1tj2b2j0gw0000gn/T/d20250318-97315-gjz2i5/cache_diff/cache_diff_derive)
    Checking proc-macro2 v1.0.94
warning: unused import: `std::str::FromStr`
 --> cache_diff_derive/src/parse_field.rs:4:5
  |
4 | use std::str::FromStr;
  |     ^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused import: `strum::IntoEnumIterator`
 --> cache_diff_derive/src/parse_field.rs:5:5
  |
5 | use strum::IntoEnumIterator;
  |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::str::FromStr`
 --> cache_diff_derive/src/parse_container.rs:4:5
  |
4 | use std::str::FromStr;
  |     ^^^^^^^^^^^^^^^^^

warning: unused import: `strum::IntoEnumIterator`
 --> cache_diff_derive/src/parse_container.rs:5:5
  |
5 | use strum::IntoEnumIterator;
  |     ^^^^^^^^^^^^^^^^^^^^^^^

    Checking quote v1.0.39
    Checking syn v2.0.100
warning: `cache_diff_derive` (lib) generated 4 warnings (run `cargo clippy --fix --lib -p cache_diff_derive` to apply 3 suggestions)
    Checking cache_diff v0.1.0 (/private/var/folders/yr/yytf3z3n3q336f1tj2b2j0gw0000gn/T/d20250318-97315-gjz2i5/cache_diff/cache_diff)
warning: `cache_diff_derive` (lib) generated 4 warnings (4 duplicates)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.08s
$ cargo test
   Compiling cache_diff_derive v0.1.0 (/private/var/folders/yr/yytf3z3n3q336f1tj2b2j0gw0000gn/T/d20250318-97315-gjz2i5/cache_diff/cache_diff_derive)
warning: unused import: `std::str::FromStr`
 --> cache_diff_derive/src/parse_field.rs:4:5
  |
4 | use std::str::FromStr;
  |     ^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused import: `strum::IntoEnumIterator`
 --> cache_diff_derive/src/parse_field.rs:5:5
  |
5 | use strum::IntoEnumIterator;
  |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::str::FromStr`
 --> cache_diff_derive/src/parse_container.rs:4:5
  |
4 | use std::str::FromStr;
  |     ^^^^^^^^^^^^^^^^^

warning: unused import: `super::*`
   --> cache_diff_derive/src/shared.rs:117:5
    |
117 | use super::*;
    |     ^^^^^^^^

warning: unused import: `strum::IntoEnumIterator`
 --> cache_diff_derive/src/parse_container.rs:5:5
  |
5 | use strum::IntoEnumIterator;
  |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: `cache_diff_derive` (lib) generated 4 warnings (run `cargo fix --lib -p cache_diff_derive` to apply 3 suggestions)
   Compiling cache_diff v0.1.0 (/private/var/folders/yr/yytf3z3n3q336f1tj2b2j0gw0000gn/T/d20250318-97315-gjz2i5/cache_diff/cache_diff)
warning: `cache_diff_derive` (lib test) generated 5 warnings (4 duplicates) (run `cargo fix --lib -p cache_diff_derive --tests` to apply 1 suggestion)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.77s
     Running unittests src/lib.rs (target/debug/deps/cache_diff-1e69b84e0de1a0a9)

running 2 tests
test tests::test_changed_metadata ... ok
test tests::test_unchanged_metadata ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/compilation_tests.rs (target/debug/deps/compilation_tests-2d3369eb9b14b304)

running 2 tests
   Compiling cache_diff_derive v0.1.0 (/private/var/folders/yr/yytf3z3n3q336f1tj2b2j0gw0000gn/T/d20250318-97315-gjz2i5/cache_diff/cache_diff_derive)
warning: unused import: `std::str::FromStr`
 --> /private/var/folders/yr/yytf3z3n3q336f1tj2b2j0gw0000gn/T/d20250318-97315-gjz2i5/cache_diff/cache_diff_derive/src/parse_field.rs:4:5
  |
4 | use std::str::FromStr;
  |     ^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused import: `strum::IntoEnumIterator`
 --> /private/var/folders/yr/yytf3z3n3q336f1tj2b2j0gw0000gn/T/d20250318-97315-gjz2i5/cache_diff/cache_diff_derive/src/parse_field.rs:5:5
  |
5 | use strum::IntoEnumIterator;
  |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::str::FromStr`
 --> /private/var/folders/yr/yytf3z3n3q336f1tj2b2j0gw0000gn/T/d20250318-97315-gjz2i5/cache_diff/cache_diff_derive/src/parse_container.rs:4:5
  |
4 | use std::str::FromStr;
  |     ^^^^^^^^^^^^^^^^^

warning: unused import: `strum::IntoEnumIterator`
 --> /private/var/folders/yr/yytf3z3n3q336f1tj2b2j0gw0000gn/T/d20250318-97315-gjz2i5/cache_diff/cache_diff_derive/src/parse_container.rs:5:5
  |
5 | use strum::IntoEnumIterator;
  |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: `cache_diff_derive` (lib) generated 4 warnings (run `cargo fix --lib -p cache_diff_derive` to apply 3 suggestions)
    Checking cache_diff v0.1.0 (/private/var/folders/yr/yytf3z3n3q336f1tj2b2j0gw0000gn/T/d20250318-97315-gjz2i5/cache_diff/cache_diff)
    Checking cache_diff-tests v0.0.0 (/private/var/folders/yr/yytf3z3n3q336f1tj2b2j0gw0000gn/T/d20250318-97315-gjz2i5/cache_diff/target/tests/trybuild/cache_diff)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.49s


test tests/fails/duplicate_attribute.rs ... ok


test should_not_compile ... ok
warning: unused import: `std::str::FromStr`
 --> /private/var/folders/yr/yytf3z3n3q336f1tj2b2j0gw0000gn/T/d20250318-97315-gjz2i5/cache_diff/cache_diff_derive/src/parse_field.rs:4:5
  |
4 | use std::str::FromStr;
  |     ^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused import: `strum::IntoEnumIterator`
 --> /private/var/folders/yr/yytf3z3n3q336f1tj2b2j0gw0000gn/T/d20250318-97315-gjz2i5/cache_diff/cache_diff_derive/src/parse_field.rs:5:5
  |
5 | use strum::IntoEnumIterator;
  |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::str::FromStr`
 --> /private/var/folders/yr/yytf3z3n3q336f1tj2b2j0gw0000gn/T/d20250318-97315-gjz2i5/cache_diff/cache_diff_derive/src/parse_container.rs:4:5
  |
4 | use std::str::FromStr;
  |     ^^^^^^^^^^^^^^^^^

warning: unused import: `strum::IntoEnumIterator`
 --> /private/var/folders/yr/yytf3z3n3q336f1tj2b2j0gw0000gn/T/d20250318-97315-gjz2i5/cache_diff/cache_diff_derive/src/parse_container.rs:5:5
  |
5 | use strum::IntoEnumIterator;
  |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: `cache_diff_derive` (lib) generated 4 warnings (run `cargo fix --lib -p cache_diff_derive` to apply 3 suggestions)
    Checking cache_diff-tests v0.0.0 (/private/var/folders/yr/yytf3z3n3q336f1tj2b2j0gw0000gn/T/d20250318-97315-gjz2i5/cache_diff/target/tests/trybuild/cache_diff)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s


There are no trybuild tests enabled yet.


test should_compile ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.68s

     Running unittests src/lib.rs (target/debug/deps/cache_diff_derive-b1392a164ca5ac04)

running 12 tests
test parse_container::tests::test_known_attributes ... ok
test parse_container::tests::test_parse_attribute ... ok
test parse_field::tests::test_parse_attributes ... ok
test parse_container::tests::test_no_fields ... ok
test parse_field::tests::test_known_attributes ... ok
test parse_container::tests::test_custom_parse_attribute ... ok
test parse_container::tests::test_all_ignored ... ok
test parse_field::tests::test_parse_field_plain ... ok
test shared::tests::test_parse_attrs_with_span_vec_demo ... ok
test shared::tests::test_parse_attrs_vec_demo ... ok
test parse_field::tests::test_requires_named_struct ... ok
test parse_container::tests::test_parses ... ok

test result: ok. 12 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests cache_diff

running 5 tests
test cache_diff/src/lib.rs - (line 101) ... ok
test cache_diff/src/lib.rs - (line 29) ... ok
test cache_diff/src/lib.rs - (line 8) ... ok
test cache_diff/src/lib.rs - (line 48) ... ok
test cache_diff/src/lib.rs - (line 72) ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.74s

   Doc-tests cache_diff_derive

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

If your project is failing or if the tests you added didn't run, here's the full project for reference:

<details>
  <summary>Full project</summary>

```
$ exa --tree --git-ignore .
.
├── cache_diff
│  ├── Cargo.toml
│  ├── src
│  │  └── lib.rs
│  └── tests
│     ├── compilation_tests.rs
│     └── fails
│        ├── duplicate_attribute.rs
│        └── duplicate_attribute.stderr
├── cache_diff_derive
│  ├── Cargo.toml
│  └── src
│     ├── lib.rs
│     ├── parse_container.rs
│     ├── parse_field.rs
│     └── shared.rs
├── Cargo.lock
└── Cargo.toml
$ cat Cargo.toml
[workspace]
members = [
    "cache_diff",
    "cache_diff_derive"
]
resolver = "2"
$ cat cache_diff/Cargo.toml
[package]
name = "cache_diff"
version = "0.1.0"
edition = "2024"

[dependencies]
cache_diff_derive = { version = "0.1.0" , optional = true, path = "../cache_diff_derive" }

[features]
derive = ["dep:cache_diff_derive"]
default = ["derive"]

[dev-dependencies]
trybuild = "1.0.104"
$ cat cache_diff_derive/Cargo.toml
[package]
name = "cache_diff_derive"
version = "0.1.0"
edition = "2024"

[dependencies]
# Turn Rust code into Tokens
quote = "1.0.37"
# Parse tokens into Rust code
syn = { version = "2.0.83", features = ["extra-traits"] }
proc-macro2 = "1.0.89"
strum = { version = "0.27.1", features = ["derive"] }
[lib]
proc-macro = true
$ cat cache_diff/src/lib.rs
// File: `cache_diff/src/lib.rs`
//! Cache Diff (derive)
//!
//! Generate the difference between two structs for the purposes of cache invalidation.
//!
//! Example:
//!
//! ```
//! use cache_diff::CacheDiff;
//!
//! #[derive(CacheDiff, Debug)]
//! struct Metadata {
//!     ruby_version: String,
//!     architecture: String,
//! }
//!
//! let diff = Metadata {ruby_version: "3.4.2".to_string(), architecture: "arm64".to_string()}
//!     .diff(&Metadata {ruby_version: "3.3.1".to_string(), architecture: "amd64".to_string()});
//!
//! assert_eq!(
//!     vec!["ruby version (3.3.1 to 3.4.2)".to_string(), "architecture (amd64 to arm64)".to_string()],
//!     diff
//! );
//! ```

//! ## Ignore attributes
//!
//! If the struct contains fields that should not be included in the diff comparison, you can ignore them:
//!
//! ```rust
//! use cache_diff::CacheDiff;
//!
//! #[derive(CacheDiff)]
//! struct Metadata {
//!     version: String,
//!
//!     #[cache_diff(ignore)]
//!     changed_by: String
//! }
//! let now = Metadata { version: "3.4.0".to_string(), changed_by: "Alice".to_string() };
//! let diff = now.diff(&Metadata { version: now.version.clone(), changed_by: "Bob".to_string() });
//!
//! assert!(diff.is_empty());
//! ```

//! ## Rename attributes
//!
//! If your field name is not descriptive enough, you can rename it:
//!
//! ```rust
//! use cache_diff::CacheDiff;
//!
//! #[derive(CacheDiff)]
//! struct Metadata {
//!     #[cache_diff(rename="Ruby version")]
//!     version: String,
//! }
//! let now = Metadata { version: "3.4.0".to_string() };
//! let diff = now.diff(&Metadata { version: "3.3.0".to_string() });
//!
//! assert_eq!("Ruby version (3.3.0 to 3.4.0)", diff.join(" "));
//! ```
//!

//! ## Handle structs missing display
//!
//! Not all structs implement the [`Display`](std::fmt::Display) trait, for example [`std::path::PathBuf`](std::path::PathBuf) requires that you call `display()` on it.
//!
//! The `#[derive(CacheDiff)]` macro will automatically handle the following conversions for you:
//!
//! - `std::path::PathBuf` (via [`std::path::Path::display`](std::path::Path::display))
//!
//! However, if you have a custom struct that does not implement [`Display`](std::fmt::Display), you can specify a function to call instead:
//!
//! ```rust
//! use cache_diff::CacheDiff;
//!
//! #[derive(CacheDiff)]
//! struct Metadata {
//!     #[cache_diff(display = my_function)]
//!     version: NoDisplay,
//! }
//!
//! #[derive(PartialEq)]
//! struct NoDisplay(String);
//! fn my_function(s: &NoDisplay) -> String {
//!     format!("custom {}", s.0)
//! }
//!
//! let now = Metadata { version: NoDisplay("3.4.0".to_string())};
//! let diff = now.diff(&Metadata { version: NoDisplay("3.3.0".to_string())});
//!
//! assert_eq!("version (custom 3.3.0 to custom 3.4.0)", diff.join(" "));
//! ```
//!

//! ## Customize one or more field differences
//!
//! You can provide a custom implementation for a diffing a subset of fields without having to roll your own implementation.
//!
//! ### Custom logic for one field example
//!
//! Here's an example where someone wants to bust the cache after N cache calls. Everything else other than `cache_usage_count` can be derived. If you want to keep the existing derived difference checks, but add on a custom one you can do it like this:
//!
//! ```rust
//! use cache_diff::CacheDiff;
//! const MAX: f32 = 200.0;
//!
//! #[derive(Debug, CacheDiff)]
//! #[cache_diff(custom = diff_cache_usage_count)]
//! pub(crate) struct Metadata {
//!     #[cache_diff(ignore = "custom")]
//!     cache_usage_count: f32,
//!
//!     binary_version: String,
//!     target_arch: String,
//!     os_distribution: String,
//!     os_version: String,
//! }
//!
//! fn diff_cache_usage_count(_old: &Metadata, now: &Metadata) -> Vec<String> {
//!     let Metadata {
//!         cache_usage_count,
//!         binary_version: _,
//!         target_arch: _,
//!         os_distribution: _,
//!         os_version: _,
//!     } = now;
//!
//!     if cache_usage_count > &MAX {
//!         vec![format!("Cache count ({}) exceeded limit {MAX}", cache_usage_count)]
//!     } else {
//!         Vec::new()
//!     }
//! }
//! ```
//!
//! In this example, four fields are derived automatically, saving us time, while one field is custom
//! using the `#[cache_diff(custom = diff_cache_usage_count)]` attribute on the struct. This tells
//! [CacheDiff] to call this function and pass in the old and current values. It expects a vector
//! with some strings if there is a difference and an empty vector if there are none.
//!
//! Don't forget to `#[cache_diff(ignore = "custom")]` any fields you're implementing yourself. You can also use this feature to
//! combine several fields into a single diff output, for example, using the previous struct, if
//! you only wanted to have one output for a combined `os_distribution` and `os_version` in one output
//! like "OS (ubuntu-22 to ubuntu-24)". Alternatively, you can use <https://github.com/schneems/magic_migrate> to
//! re-arrange your struct to only have one field with a custom display.
//!
#[cfg(feature = "derive")]
pub use cache_diff_derive::CacheDiff;
// Code
pub trait CacheDiff {
    fn diff(&self, old: &Self) -> Vec<String>;
}

#[cfg(test)]
mod tests {
    // Test use
    use super::*;
    // Test code
    struct Metadata {
        ruby_version: String,
        architecture: String,
    }

    impl CacheDiff for Metadata {
        fn diff(&self, old: &Self) -> Vec<String> {
            let mut diff = Vec::new();

            if self.ruby_version != old.ruby_version {
                diff.push(format!("ruby version ({} to {})",
                old.ruby_version,
                self.ruby_version))
            }
            if self.architecture != old.architecture {
                diff.push(
                    format!("architecture ({} to {})",
                    old.architecture,
                    self.architecture)
                )
            }
            diff
        }
    }

    #[test]
    fn test_changed_metadata() {
        let old = Metadata {
            ruby_version: "3.3.1".to_string(),
            architecture: "amd64".to_string()
        };
        let new = Metadata {
            ruby_version: "3.4.2".to_string(),
            architecture: "arm64".to_string()
        };

        assert_eq!(
            vec![
                "ruby version (3.3.1 to 3.4.2)".to_string(),
                "architecture (amd64 to arm64)".to_string()
            ],
            new.diff(&old)
        );
    }

    #[test]
    fn test_unchanged_metadata() {
        let old = Metadata {
            ruby_version: "3.1.4".to_string(),
            architecture: "amd64".to_string()
        };

        let diff = old.diff(&old);
        assert!(
            diff.is_empty(),
            "Expected diff to be empty but is {:?}",
            diff
        );
    }
}
$ cat cache_diff_derive/src/lib.rs
// File: `cache_diff_derive/src/lib.rs`
mod parse_field;
mod parse_container;
mod shared;
use proc_macro::TokenStream;
use parse_container::ParseContainer;
use parse_field::ParseField;
// Code
pub(crate) const NAMESPACE: &str = "cache_diff";
pub(crate) const MACRO_NAME: &str = "CacheDiff";

#[proc_macro_derive(CacheDiff, attributes(cache_diff))]
pub fn cache_diff(item: TokenStream)
    -> TokenStream {
    create_cache_diff(item.into())
        .unwrap_or_else(syn::Error::into_compile_error)
        .into()
}

fn create_cache_diff(item: proc_macro2::TokenStream) -> syn::Result<proc_macro2::TokenStream> {
    let ParseContainer {
        ident,
        generics,
        custom,
        fields,
    } = ParseContainer::from_derive_input(&syn::parse2(item)?)?;

    let custom_diff = if let Some(ref custom_fn) = custom {
        quote::quote! {
            let custom_diff = #custom_fn(old, self);
            for diff in &custom_diff {
                differences.push(diff.to_string())
            }
        }
    } else {
        quote::quote! {}
    };

    let mut comparisons = Vec::new();
    for field in fields.iter() {
        let ParseField {
            ident,
            name,
            ignore,
            display,
        } = field;

        if ignore.is_none() {
            comparisons.push(quote::quote! {
                if self.#ident != old.#ident {
                    differences.push(
                        format!("{name} ({old} to {new})",
                            name = #name,
                            old = #display(&old.#ident),
                            new = #display(&self.#ident)
                        )
                    );
                }
            });
        }
    }
    let (impl_generics, type_generics, where_clause) = generics.split_for_impl();
    Ok(quote::quote! {
        impl #impl_generics ::cache_diff::CacheDiff for #ident #type_generics #where_clause {
            fn diff(&self, old: &Self) -> ::std::vec::Vec<String> {
                let mut differences = ::std::vec::Vec::new();
                #custom_diff
                #(#comparisons)*
                differences
            }
        }
    })
}
$ cat cache_diff_derive/src/parse_field.rs
// File: `cache_diff_derive/src/parse_field.rs`
use crate::MACRO_NAME;
use syn::spanned::Spanned;
use std::str::FromStr;
use strum::IntoEnumIterator;
use crate::shared::WithSpan;
// Code
/// Field (i.e. `name: String`) of a container (struct) and its parsed attributes
/// i.e. `#[cache_diff(rename = "Ruby version")]`
#[derive(Debug)]
pub(crate) struct ParseField {
    /// The proc-macro identifier for a field i.e. `name: String` would be a programmatic
    /// reference to `name` that can be used along with `quote!` to produce code.
    pub(crate) ident: syn::Ident,
    /// What the user will see when this field differs and invalidates the cache
    /// i.e. `age: usize` will be `"age"`.
    pub(crate) name: String,
    /// Whether or not the field is included in the derived diff comparison
    pub(crate) ignore: Option<String>,
    /// The function to use when rendering values on the field
    /// i.e. `age: 42` will be `"42"`
    pub(crate) display: syn::Path,
}

impl ParseField {
    pub(crate) fn from_field(field: &syn::Field) -> Result<Self, syn::Error> {
        let ident = field.ident.clone().ok_or_else(|| {
            syn::Error::new(
                field.span(),
                format!("{MACRO_NAME} can only be used on structs with named fields"),
            )
        })?;

        let mut lookup = crate::shared::attribute_lookup::<ParseAttribute>(&field.attrs)?;
        let name = lookup
            .remove(&KnownAttribute::rename)
            .map(WithSpan::into_inner)
            .map(|parsed| match parsed {
                ParseAttribute::rename(inner) => inner,
                _ => unreachable!(),
            })
            .unwrap_or_else(|| ident.to_string().replace("_", " "));
        let display = lookup
            .remove(&KnownAttribute::display)
            .map(WithSpan::into_inner)
            .map(|parsed| match parsed {
                ParseAttribute::display(inner) => inner,
                _ => unreachable!(),
            })
            .unwrap_or_else(|| {
                if is_pathbuf(&field.ty) {
                    syn::parse_str("std::path::Path::display")
                        .expect("PathBuf::display parses as a syn::Path")
                } else {
                    syn::parse_str("std::convert::identity")
                        .expect("std::convert::identity parses as a syn::Path")
                }
            });
        let ignore = lookup
            .remove(&KnownAttribute::ignore)
            .map(WithSpan::into_inner)
            .map(|parsed| match parsed {
                ParseAttribute::ignore(inner) => inner,
                _ => unreachable!(),
            });
        crate::shared::check_empty(lookup)?;

        Ok(ParseField {
            ident,
            name,
            ignore,
            display,
        })
    }
}


/// A single attribute
#[derive(strum::EnumDiscriminants, Debug, PartialEq)]
#[strum_discriminants(
    name(KnownAttribute),
    derive(strum::EnumIter, strum::Display, strum::EnumString, Hash)
)]
enum ParseAttribute {
    #[allow(non_camel_case_types)]
    rename(String), // #[cache_diff(rename="...")]
    #[allow(non_camel_case_types)]
    display(syn::Path), // #[cache_diff(display=<function>)]
    #[allow(non_camel_case_types)]
    ignore(String), // #[cache_diff(ignore)]
}

impl syn::parse::Parse for KnownAttribute {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let identity = input.parse::<syn::Ident>()?;
        crate::shared::known_attribute(&identity)
    }
}

impl syn::parse::Parse for ParseAttribute {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let key: KnownAttribute = input.parse()?;

        match key {
            KnownAttribute::rename => {
                input.parse::<syn::Token![=]>()?;
                Ok(ParseAttribute::rename(
                    input.parse::<syn::LitStr>()?.value(),
                ))
            }
            KnownAttribute::display => {
                input.parse::<syn::Token![=]>()?;
                Ok(ParseAttribute::display(input.parse()?))
            }
            KnownAttribute::ignore => {
                if input.peek(syn::Token![=]) {
                    input.parse::<syn::Token![=]>()?;
                    Ok(ParseAttribute::ignore(
                        input.parse::<syn::LitStr>()?.value(),
                    ))
                } else {
                    Ok(ParseAttribute::ignore("default".to_string()))
                }
            }
        }
    }
}

fn is_pathbuf(ty: &syn::Type) -> bool {
    if let syn::Type::Path(type_path) = ty {
        if let Some(segment) = type_path.path.segments.last() {
            return segment.ident == "PathBuf" && segment.arguments == syn::PathArguments::None;
        }
    }
    false
}

#[cfg(test)]
mod tests {
    // Test use
    use super::*;
    // Test code
    #[test]
    fn test_parse_field_plain() {
        let field: syn::Field = syn::parse_quote! {
            ruby_version: String
        };

        let parsed = ParseField::from_field(&field).unwrap();
        assert_eq!("ruby version".to_string(), parsed.name);
    }

    #[test]
    fn test_requires_named_struct() {
        let field: syn::Field = syn::parse_quote! {()};

        let result = ParseField::from_field(&field);
        assert!(result.is_err(), "Expected an error, got {:?}", result);
        assert_eq!(
            format!("{}", result.err().unwrap()),
            r#"CacheDiff can only be used on structs with named fields"#
        );
    }

    #[test]
    fn test_known_attributes() {
        let parsed: KnownAttribute = syn::parse_str("rename").unwrap();
        assert_eq!(KnownAttribute::rename, parsed);

        let parsed: KnownAttribute = syn::parse_str("ignore").unwrap();
        assert_eq!(KnownAttribute::ignore, parsed);

        let parsed: KnownAttribute = syn::parse_str("display").unwrap();
        assert_eq!(KnownAttribute::display, parsed);

        let result: Result<KnownAttribute, syn::Error> = syn::parse_str("unknown");
        assert!(result.is_err(), "Expected an error, got {:?}", result);
        assert_eq!(
            format!("{}", result.err().unwrap()),
            r#"Unknown cache_diff attribute: `unknown`. Must be one of `rename`, `display`, `ignore`"#
        );
    }

    #[test]
    fn test_parse_attributes() {
        let parsed: ParseAttribute = syn::parse_str(r#"rename = "Ruby version""#).unwrap();
        assert_eq!(ParseAttribute::rename("Ruby version".to_string()), parsed);

        let parsed: ParseAttribute = syn::parse_str(r#"display= my_function"#).unwrap();
        assert!(matches!(parsed, ParseAttribute::display(_))); let parsed: ParseAttribute = syn::parse_str(r#"ignore = "i have my reasons""#).unwrap();
        assert!(matches!(parsed, ParseAttribute::ignore(_)));

        let parsed: ParseAttribute = syn::parse_str("ignore").unwrap();
        assert!(matches!(parsed, ParseAttribute::ignore(_)));
    }
}
$ cat cache_diff_derive/src/parse_container.rs
// File: `cache_diff_derive/src/parse_container.rs`
use crate::parse_field::ParseField;
use crate::MACRO_NAME;
use std::str::FromStr;
use strum::IntoEnumIterator;
use crate::NAMESPACE;
use crate::shared::WithSpan;
// Code
/// Container (i.e. struct Metadata { ... }) and its parsed attributes
/// i.e. `#[cache_diff( ... )]`
#[derive(Debug)]
pub(crate) struct ParseContainer {
    /// The proc-macro identifier for a container i.e. `struct Metadata { }` would be a programmatic
    /// reference to `Metadata` that can be used along with `quote!` to produce code.
    pub(crate) ident: syn::Ident,
    /// Info about generics, lifetimes and where clauses i.e. `struct Metadata<T> { name: T }`
    pub(crate) generics: syn::Generics,
    /// An optional path to a custom diff function
    /// Set via attribute on the container i.e. `#[cache_diff(custom = <function>)]`
    pub(crate) custom: Option<syn::Path>,
    /// Fields (i.e. `name: String`) and their associated attributes i.e. `#[cache_diff(...)]`
    pub(crate) fields: Vec<ParseField>,
}

impl ParseContainer {
    pub(crate) fn from_derive_input(input: &syn::DeriveInput) -> Result<Self, syn::Error> {
        let ident = input.ident.clone();
        let generics = input.generics.clone();
        let mut lookup = crate::shared::attribute_lookup::<ParseAttribute>(&input.attrs)?;
        let custom = lookup
            .remove(&KnownAttribute::custom)
            .map(WithSpan::into_inner)
            .map(|parsed| match parsed {
                ParseAttribute::custom(path) => path,
            });

        let fields = match input.data {
            syn::Data::Struct(syn::DataStruct {
                fields: syn::Fields::Named(syn::FieldsNamed { ref named, .. }),
                ..
            }) => named,
            _ => {
                return Err(syn::Error::new(
                    ident.span(),
                    format!("{MACRO_NAME} can only be used on named structs"),
                ))
            }
        }
        .into_iter()
        .map(ParseField::from_field)
        .collect::<Result<Vec<ParseField>, syn::Error>>()?;

        crate::shared::check_empty(lookup)?;

        if let Some(field) = fields
            .iter()
            .find(|field| matches!(field.ignore.as_deref(), Some("custom")))
        {
            if custom.is_none() {
                let mut error = syn::Error::new(
                    proc_macro2::Span::call_site(),
                    format!("`Expected `{ident}` to implement the `custom` attribute `#[{NAMESPACE}(custom = <function>)]`, but it does not"),
                );
                error.combine(syn::Error::new(
                    field.ident.span(),
                    format!(
                        "Field `{}` is ignored and requires `{ident}` to implement `custom`",
                        field.ident
                    ),
                ));
                return Err(error);
            }
        }

        if fields.iter().any(|f| f.ignore.is_none()) {
            Ok(ParseContainer {
                ident,
                generics,
                fields,
                custom,
            })
        } else {
            Err(syn::Error::new(ident.span(), format!("No fields to compare for {MACRO_NAME}, ensure struct has at least one named field that isn't `{NAMESPACE}(ignore)`")))
        }
    }
}

/// A single attribute
#[derive(strum::EnumDiscriminants, Debug, PartialEq)]
#[strum_discriminants(
    name(KnownAttribute),
    derive(strum::EnumIter, strum::Display, strum::EnumString, Hash)
)]
enum ParseAttribute {
    #[allow(non_camel_case_types)]
    custom(syn::Path), // #[cache_diff(custom=<function>)]
}

impl syn::parse::Parse for KnownAttribute {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let identity: syn::Ident = input.parse()?;
        crate::shared::known_attribute(&identity)
    }
}

impl syn::parse::Parse for ParseAttribute {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let key: KnownAttribute = input.parse()?;
        input.parse::<syn::Token![=]>()?;
        match key {
            KnownAttribute::custom => Ok(ParseAttribute::custom(input.parse()?)),
        }
    }
}

#[cfg(test)]
mod tests {
    // Test use
    use super::*;
    // Test code
    #[test]
    fn test_parses() {
        let container = ParseContainer::from_derive_input(&syn::parse_quote! {
            struct Metadata {
                version: String
            }
        })
        .unwrap();
        assert_eq!(1, container.fields.len());

        let container = ParseContainer::from_derive_input(&syn::parse_quote! {
            struct Metadata {
                version: String,
                checksum: String
            }
        })
        .unwrap();
        assert_eq!(2, container.fields.len());
    }

    #[test]
    fn test_known_attributes() {
        let attribute: KnownAttribute = syn::parse_str("custom").unwrap();
        assert_eq!(KnownAttribute::custom, attribute);
    }

    #[test]
    fn test_parse_attribute() {
        let attribute: ParseAttribute = syn::parse_str("custom = my_function").unwrap();
        assert!(matches!(attribute, ParseAttribute::custom(_)));

        let result: Result<ParseAttribute, syn::Error> = syn::parse_str("unknown");
        assert!(result.is_err(), "Expected an error, got {:?}", result);
        assert_eq!(
            r"Unknown cache_diff attribute: `unknown`. Must be one of `custom`",
            format!("{}", result.err().unwrap()),
        );
    }

    #[test]
    fn test_custom_parse_attribute() {
        let input: syn::DeriveInput = syn::parse_quote! {
            #[cache_diff(custom = my_function)]
            struct Metadata {
                name: String
            }
        };

        assert!(matches!(
            crate::shared::attribute_lookup::<ParseAttribute>(&input.attrs)
                .unwrap()
                .remove(&KnownAttribute::custom)
                .unwrap()
                .into_inner(),
            ParseAttribute::custom(_)
        ));
    }

    #[test]
    fn test_no_fields() {
        let result = ParseContainer::from_derive_input(&syn::parse_quote! {
            struct Metadata { }
        });
        assert!(result.is_err(), "Expected an error, got {:?}", result);
        assert_eq!(
            format!("{}", result.err().unwrap()),
            r#"No fields to compare for CacheDiff, ensure struct has at least one named field that isn't `cache_diff(ignore)`"#
        );
    }

    #[test]
    fn test_all_ignored() {
        let result = ParseContainer::from_derive_input(&syn::parse_quote! {
            struct Metadata {
                #[cache_diff(ignore)]
                version: String
            }
        });
        assert!(result.is_err(), "Expected an error, got {:?}", result);
        assert_eq!(
            format!("{}", result.err().unwrap()),
            r#"No fields to compare for CacheDiff, ensure struct has at least one named field that isn't `cache_diff(ignore)`"#
        );
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->
</details>


If your code compiles, congratulations, you just earned your Derive-ing license!


