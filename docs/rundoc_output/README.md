<!-- STOP
  This file was generated by a rundoc script, do not modify it.

  Instead modify the rundoc script and re-run it.

  Command: /Users/rschneeman/.gem/ruby/3.4.1/bin/rundoc docs/RUNDOC.md
STOP -->
## Create the project

Create a top level workspace directory

```
$ mkdir cache_diff
$ cd cache_diff
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

In file `Cargo.toml` write:

```
[workspace]
members = [
    "cache_diff",
    "cache_diff_derive"
]
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Now initialize two projects:

```
$ cargo init cache_diff --lib
    Creating library package
warning: compiling this new package may not work due to invalid workspace configuration

failed to load manifest for workspace member `/private/var/folders/yr/yytf3z3n3q336f1tj2b2j0gw0000gn/T/d20250213-12744-woay1/cache_diff/cache_diff_derive`
referenced by workspace at `/private/var/folders/yr/yytf3z3n3q336f1tj2b2j0gw0000gn/T/d20250213-12744-woay1/cache_diff/Cargo.toml`

Caused by:
  failed to read `/private/var/folders/yr/yytf3z3n3q336f1tj2b2j0gw0000gn/T/d20250213-12744-woay1/cache_diff/cache_diff_derive/Cargo.toml`

Caused by:
  No such file or directory (os error 2)
note: see more `Cargo.toml` keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
$ cargo init cache_diff_derive --lib
    Creating library package
warning: virtual workspace defaulting to `resolver = "1"` despite one or more workspace members being on edition 2021 which implies `resolver = "2"`
note: to keep the current resolver, specify `workspace.resolver = "1"` in the workspace root's manifest
note: to use the edition 2021 resolver, specify `workspace.resolver = "2"` in the workspace root's manifest
note: for more details see https://doc.rust-lang.org/cargo/reference/resolver.html#resolver-versions
note: see more `Cargo.toml` keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Write a top level `.gitignore`.

In file `.gitignore` write:

```
/target
.DS_Store
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

The project now looks like this:

```
$ exa --tree --git-ignore .
.
├── cache_diff
│  ├── Cargo.toml
│  └── src
│     └── lib.rs
├── cache_diff_derive
│  ├── Cargo.toml
│  └── src
│     └── lib.rs
└── Cargo.toml
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

We need two crates because a procmacro must live in a stand alone crate. This allows Rust to compile and run that code before the rest of the code in a project is compiled. A limitation is that it can only export macros, so we need somewhere else for other public things (like traits) to live.

## Define the CacheDiff trait

Once the project is setup, we'll start off by defining a public trait.

In file `cache_diff/src/lib.rs` write:

```rust
pub trait CacheDiff {
    fn diff(&self, old: &Self) -> Vec<String>;
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

>note
>This is how I recommend starting: define a manual workflow first and once you're happy with that, then move on to automation/metaprogramming via proc-macro.

This trait is short. It's designed to communicate that a struct is intended to be used as a cache key. When compared to an older version of the struct, it should return an empty `Vec` if there are no differences (and the cache should be preserved). When the cache should be cleared, the entries represent list of human readable reasons why the cache was cleared (what is different between the two structs). The primary use case is that "metadata" structs are serialized to TOML to know when we can invalidate a layer in a [Cloud Native Buildpack (CNB) written in Rust with the libcnb.rs](https://github.com/heroku/libcnb.rs).


## Manually implement the trait

Without a macro, a maintainer would need to manually implement the trait, here's a test demonstrating what that would look like.

First we will add a stringly typed `Metadata` struct and implement `CacheDiff` for this struct to simulate a world where we're storing a version of an architecture dependent binary that we're installing.

At the end of `cache_diff/src/lib.rs` add:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    struct Metadata {
        version: String,
        architecture: String,
    }

    impl CacheDiff for Metadata {
        fn diff(&self, old: &Self) -> Vec<String> {
            let mut diff = Vec::new();

            if self.version != old.version {
                diff.push(format!("version (`{}` to `{}`)",
                old.version,
                self.version))
            }
            if self.architecture != old.architecture {
                diff.push(
                    format!("architecture (`{}` to `{}`)",
                    old.architecture,
                    self.architecture))
            }
            diff
        }
    }
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

> Skip the rest of this section if: You already understand how the trait interface could be used and could write your own tests for it.

Now, add a test for this behavior.

At the end of `cache_diff/src/lib.rs` add:

```rust
    #[test]
    fn test_changed_metadata() {
        let old = Metadata {
            version: "3.1.4".to_string(),
            architecture: "amd64".to_string()
        };
        let new = Metadata {
            version: "3.5.0".to_string(),
            architecture: "arm64".to_string()
        };

        assert_eq!(
            vec![
                "version (`3.1.4` to `3.5.0`)".to_string(),
                "architecture (`amd64` to `arm64`)".to_string()
            ],
            new.diff(&old)
        );
    }
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

It's usually a good idea to assert both positive an negative behavior.

At the end of `cache_diff/src/lib.rs` add:

```rust
    #[test]
    fn test_unchanged_metadata() {
        let old = Metadata {
            version: "3.1.4".to_string(),
            architecture: "amd64".to_string()
        };

        let diff = old.diff(&old);
        assert!(
            diff.is_empty(),
            "Expected diff to be empty but is {:?}",
            diff
        );
    }
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

To get our code to compile, make sure there's a trailing curly bracket.

At the end of `cache_diff/src/lib.rs` add:

```
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Your file should now look like this:

```
$ cat cache_diff/src/lib.rs
pub trait CacheDiff {
    fn diff(&self, old: &Self) -> Vec<String>;
}
#[cfg(test)]
mod tests {
    use super::*;

    struct Metadata {
        version: String,
        architecture: String,
    }

    impl CacheDiff for Metadata {
        fn diff(&self, old: &Self) -> Vec<String> {
            let mut diff = Vec::new();

            if self.version != old.version {
                diff.push(format!("version (`{}` to `{}`)",
                old.version,
                self.version))
            }
            if self.architecture != old.architecture {
                diff.push(
                    format!("architecture (`{}` to `{}`)",
                    old.architecture,
                    self.architecture))
            }
            diff
        }
    }

    #[test]
    fn test_changed_metadata() {
        let old = Metadata {
            version: "3.1.4".to_string(),
            architecture: "amd64".to_string()
        };
        let new = Metadata {
            version: "3.5.0".to_string(),
            architecture: "arm64".to_string()
        };

        assert_eq!(
            vec![
                "version (`3.1.4` to `3.5.0`)".to_string(),
                "architecture (`amd64` to `arm64`)".to_string()
            ],
            new.diff(&old)
        );
    }
    #[test]
    fn test_unchanged_metadata() {
        let old = Metadata {
            version: "3.1.4".to_string(),
            architecture: "amd64".to_string()
        };

        let diff = old.diff(&old);
        assert!(
            diff.is_empty(),
            "Expected diff to be empty but is {:?}",
            diff
        );
    }
}
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

And when you run tests, it should look a little like this:

```
$ cargo test
warning: virtual workspace defaulting to `resolver = "1"` despite one or more workspace members being on edition 2021 which implies `resolver = "2"`
note: to keep the current resolver, specify `workspace.resolver = "1"` in the workspace root's manifest
note: to use the edition 2021 resolver, specify `workspace.resolver = "2"` in the workspace root's manifest
note: for more details see https://doc.rust-lang.org/cargo/reference/resolver.html#resolver-versions
   Compiling cache_diff_derive v0.1.0 (/private/var/folders/yr/yytf3z3n3q336f1tj2b2j0gw0000gn/T/d20250213-12744-woay1/cache_diff/cache_diff_derive)
   Compiling cache_diff v0.1.0 (/private/var/folders/yr/yytf3z3n3q336f1tj2b2j0gw0000gn/T/d20250213-12744-woay1/cache_diff/cache_diff)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.19s
     Running unittests src/lib.rs (target/debug/deps/cache_diff-21705cfac33b14eb)

running 2 tests
test tests::test_changed_metadata ... ok
test tests::test_unchanged_metadata ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/lib.rs (target/debug/deps/cache_diff_derive-d36b40bd53c9f8fd)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests cache_diff

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests cache_diff_derive

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

The `CacheDiff` trait isn't too complicated, but there's a lot of repetition since the text of the output matches the field names (i.e. `metadata.version`), and there's room to mess up the output like inverting the version number position or comparing one field and displaying values for a different one.

If only there was a way to reduce repetition and eliminate silly logic errors. Some kind of code that could reflect on the struct we want to write and generate that output for us. Lucky for us, there is! That's what we'll work towards next.

